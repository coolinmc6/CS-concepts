
DOUG LLOYD: As we continue to put C in the rear view mirror behind us,
I wanted to now introduce you to another programming language
that we'll use a lot in CS50, Python.
Now, of course we're not going to be able to cover Python in nearly as
much depth as we spent in those 30 or so videos we spent
talking about C in prior weeks, but the goal here
is really to give you an introduction to the language
so you can see some of the tools it has and figure out how you might
want to use them best on your own.
Now, Python is an example of a pretty commonly used modern programming
language.
It's probably in the top five or six at the time this video is being recorded.
It's been around though for a while.
It's been around for over 25 years, and it's really
a great language choice for making some complex operations in C a lot easier.
So you may recall working with C that string manipulation
can be really challenging.
And it also simplifies things like networking
and really it's a general purpose utility language
that you can use to do a lot of stuff.
It's also very popular right now among data scientists
for processing large sets of data and generating graphs, charts,
and results from that.
There is some good news too as well.
So Python is pretty inspired by C as a lot of modern programming languages
are honestly.
And its syntax is going to look a little bit different,
but it has some pretty consistent look and feel things to it.
You're not going to see as many curly braces or anything like that that you
didn't in C, but hopefully some of the style
lessons that you learned along the way will come in handy for you here.
To start writing a Python file it's pretty straightforward.
All you've got to do is open up a file with the dot py
file extension inside of CS50 IDE.
That will automatically syntax highlight it for you
and show you that what you're typing is proper valid Python or not.
But unlike C, Python is not a compiled language.
Or it is not necessarily a compiled language.
Python programs can be run in a Python interpreter.
This is similar to PHP if you're familiar with that language
as well where you can just write your lines of code
and have the computer just run through them one by one executing as you go.

Python programs can work in exactly the same way.
One really important caveat before we dive into this.
In CS50, we teach Python 3.
There are actually two pretty popular versions
of Python, Python 2 and Python 3.
So all the syntax and everything we're going to talk about in this video
is Python 3 specific, and in general, if you're
looking up documentation on your own trying
to figure out how to use a Python function
or figure out if there's a Python function that does something
you're looking to do, be sure to include Python 3 in your search
instead of just saying Python, because you might get Python 2 results which
would not necessarily work.
So let's go through some of the basic things that we can do in C
and show you how we can do them in Python.
So variables have two big differences from C.
We don't have to specify a type anymore so that's pretty cool.
And we can declare them only by initialization.
So you may recall in C that we could declare
a variable by sayings for example int x semicolon,
but not actually assign a value to it, not initialize it.
In Python, we can only declare variables by initializing them.
So where in C we might say something like this, int x equals 54 semicolon.
In Python, we just say x equals 54 and that creates a new variable for us
in Python called x and assigns it the value 54.
And notice here, Python statements don't need to end with semicolons.
So that might be a nice thing if you're the kind of person who
like me oftentimes will forget to put a semicolon at the end of a line.
In Python you don't need to include them.
You can include them and it won't have a problem,
but you can also omit them to make your code look a little bit cleaner.
Similarly, can we declare the following, string phrase equals this is CS50,
and to do this in C we would have to pound include
the CS50 library because string is not a native data type in C.
But it is in Python.
We can just say, phrase equals this is CS50.
And in fact, we don't even have to use double quotes.
Python actually support strings with double quotes or single quotes.
And this is actually really useful if you
need to declare a string that has quotation marks in it,
you can just kind of alternate back and forth
between using single quotes on the outside, double quotes on the inside,
single quotes inside of that, and so on, and that's actually kind of useful
if you're the kind of person who's working with a lot of text for example
in particular with databases.
The conditional statements from C are all available for you to use,
but they might look a teeny bit different now.
So whereas in C we might say something like this, if y is less than 43,
or z equals equals 15, and then we have some code.
That's not what it looks like in Python.
It looks a little something like this.
If y is less than 43 or literally using the word or now,
not using two vertical bars, because in Python we can do that.
Or z equals 15 colon, instead of open curly brace
and then whatever code we have close curly brace and then some code below.
In Python, all comments are introduced with the pound sign or hash
mark like this.
So this basically just indicates that this is a comment.
So here's an if else statement that might be familiar
with from C. In Python, it's going to look pretty similar.
Again, it looks just like this where we now--
well actually, we have and here.
So previously in C we have if y is less than 43 and z is equal to 15.
In Python, just like where or was translated from two vertical bars
to the word or, in Python we've translated two ampersands
to the word and.
So we don't have to use two ampersands anymore,
we can just literally say the word and.
Then we have the else there.
The else is not that big of a difference.
This one is a little bit different though.
So if course number equals 50 we do one thing.
Else if course number is not equal to 51 we do something else.
In Python, we don't have else if, we have elif, not elseif.
But otherwise it's going to behave exactly the same.
So just again, trying to cut a couple of characters out of what we have to type.
And again, instead of using course num not equal to 51, we can do elif
not course num equals 51.
Again, it's a little bit of a twist, but we can again use these English words.
We're not having to use the exclamation point symbol, the vertical bar
symbol, the ampersand, all that sort of taking away that junk
and we can just start to speak English almost in Python.
And that's actually one of the reasons that people find this language popular
is because generally, if you think you want to write something in English,
you're actually pretty much on the way to writing it the same thing in Python.
As I pointed out, we don't have else if, it's just one word here, elif.
Just like before though, we end our lines now with colons
and we indent our code blocks.
And as we'll see a bit later, indenting in Python
is super, super, super important.
We also have question mark colon, the ternary operator.
It looks a little bit different.
I'm going to show it here just you see it,
but generally it's a little bit weird so you might not
use it all that frequently.
So here what we're doing is we're getting a character in C,
and then if that character is a letter, alphabetic gets assigned to the value
true, otherwise it gets assigned to the value false.
Here, that line would look like this.
It's a single line of code, and we have our true and false.
Notice that they are now capitalized as opposed to in C
where they're lower case.
Again, these little syntax differences are the kinds
of things that when you're learning a new language,
these are the things that will vary a little bit from language to language.
But it's the general concepts here that we're concerned with
and these will become second nature to you
pretty quickly if you use Python for more than a week or so.
We have this function called input, which we can use.
It's native to Python.
And we can use that to collect user input at the command line,
just like we did in CS50's library with get char, get float, get int,
and so on.
Although those functions, again, are also
available for you to use in Python.
We rewrote them in Python for you.
We have two kinds of loops in Python.
So in C we had three.
We had while loops, do while loops, and for loops.
Here in Python, we don't have do while loops anymore.
We only have the two, while and for, although they're
a bit more flexible here.
So here's an example of some C code where we're using a while loop.
We initialize a counter to 0, and then so long
as that counter is less than 100, we print out the number
and then we increment the counter by 1.
So this loop will run 100 times, printing the numbers 0 1 dot, dot, dot,
dot, dot all the way down to 99.
Do this same thing in Python, it would look a little something like this.
Counter equals zero-- again, we're leaving off the type specifier
because it's Python, we don't need it.
There's no semicolons at the end.
And then while counter is less than 100-- again,
no extraneous parentheses here either.
We're really trying to streamline what we can.
Then we just print out the counter and we say, counter plus equals 1.
This is another catch here in Python.
Plus plus is not the increment by one operator.
We have to very explicitly call out counter plus equals 1.
We can't say counter plus plus.
But otherwise, this would do exactly the same thing.
Print out one line at a time the numbers 0 to 99.
And notice also that we don't have to include that backslash n that we
did in C when we were using printf.
In Python, by default it assumes that if you're printing something,
it's just going to tack a new line on at the very end for you automatically.
So that's kind of nice.
Here's a for loop that would do again pretty much exactly
the same thing that we just saw.
It initializes the variable x to 0, and then so long as x is less than 100
it will print out the number, and then at the end
of every iteration of the loop it will execute the line x plus plus.
So we'll again have 0 1 dot, dot, dot, dot, dot all the way down to 99.
In Python it looks a little something like this.
For x in range 1000 print x.
So range is a function that will give us basically a list,
and we'll talk about what that is in just a moment, of all the numbers
from 0 to 100 but not including 100.
So this would give us a list of 0 to 99.
And then we're just going to print out every number in that list
starting at the beginning, going all the way to the end.
In a for loop where we wanted to count by twos
we might do something like this.
In Python we can also do that, we just have
to add one extra parameter to our range function.
We set a start point, we set with the endpoint,
and we set how much we want to skip by.
So this is a list of all of the integers from up to 100
but not counting 100, counting by twos.
So this would generate a list for us of 0, 2, 4, 6, 8 and so on all the way
up to 98.
So arrays.
So arrays are really where Python is going
to start to shine and show us some of the real advantages
it has over a language like C, which is a little more constricted in what
it can do with arrays because of two things.
One, they're fixed size, and two, we can only store one type of variable
in them.
We can only store an array of all integers, all characters, all
some structure that we created, and so on.
In Python, we don't actually call them arrays.
We call them lists, but they're effectively the same general idea,
the same concept we're familiar with.
They're not fixed in size.
So similar to a linked list really we can grow and shrink them as we need,
as our program demands more memory or less memory
to be consumed by the list the language is flexible enough
to allow us to do that.
And we can always add more things on, splice or remove things from the middle
pretty easily.
So let's get in the habit of calling these things lists now instead
of arrays.
But to declare a list it's really pretty straightforward.
Nums equals square brackets.
There we go.
We have it.
That's an empty list or an empty array.
But that's all we really need to do to do it.
We could create a list that has a couple of elements pre-populated into it.
Nums equals 1, 2, 3, 4.
That is an explicitly created list.
Python also has support for something called a list comprehension, which
we're not going to get into in a lot of detail here,
but I want to show you what it looks like.
Nums equals x, and then I have a for loop inside
of my declaration of my list.
This is called the list comprehension, and basically what this is doing
is I'm using the for loop to generate a list of numbers for me.
And instead of doing anything with that list like where I as printing them out
before, I'm using that list that the for loop
generates to assign it to nums instead.
So what this would do is create a list of 500 elements, all
of the numbers up from 0 all the way up to 499,
because again range excludes that final parameter.
So we're not including 500.
Our range has 500 things in it, but it's going from 0 to 499, not 0 to 500
which would be 501 things in the list.
Now, instead of the square bracket syntax,
there's also just saying nums equals list parentheses, which
is a function that creates a list, and if you don't pass anything
in it returns an empty list or an empty set of square brackets.
So that's exactly the same as what we saw just a moment ago
with the blank empty list.
Now we have the following.
We could say nums equals 1, 2, 3, 4.
So that's explicitly creating a list of four elements.
We can attach an element to the end of the list.
We can say, nums dot append 5.
And what that's going to do is that's going to add 5 to the end of the list.
It's going to tack it on at the very end.
This line of code would do exactly the same thing.
Nums dot insert parentheses 4 comma 5.
Well, what does this mean?
Well, what's happening here is we're inserting in the fourth position,
again counting from 0, and if you remember
how we count in C we know that 1 here is in the zeroth position,
2 is in the first position, 3 is in the second position,
4 is in the third position.
So what we're doing here is really just inserting
into the fourth position the value 5.
So this line, and this one that we just saw do exactly the same thing.
They put a 5 at the end of that array.
This also does the same thing.
Nums square bracket len nums colon 5 equals 5.
Little bit weirder, but basically what we're doing here is we're
creating another list effectively, and we're splicing it
on to the one that exists before.
So what I'm saying is, I'm creating a new list.
There's a list there with a single element, 5.
And I'm saying, the nums list from position 4, which is the length of nums
forward, gets this list assigned to it.
So if i had put 5 comma 6 there, after this would execute
I would end up with nums equals 1, 2, 3, 4, 5, 6.
So this is how I can perhaps attach one list
to the end of another list, as opposed to attaching
one element to the end of a list.
So len nums works just like strlen might if you're familiar with that from C.
It calculates the length of a list.
So len now becomes a function in Python that
is usable to calculate not just the length of a string,
but the length of any arbitrary list.
Kind of useful.
All right, here's a new data type that we've never--
or a new kind of way of storing data in Python
that we're not familiar with from C and that's called a tuple.
So what a tuple is, it is an ordered, immutable set of data,
basically what we're saying here is we have a collection of a couple of things
that we will never change, but the order matters.
And we'll take a look at an example in just a moment of what a tuple might
look like or what a list of tuples might look like
and why we might want to work them.
But they're really good for associating collections of data.
They're really fast to navigate in Python.
And they're really kind of analogous to a structure in C where the values will
never change, but you've arranged them because of the way
you arranged your fields in C in a particular order.
So here, for example is a list--
so a list which we just talked about--
of tuples.
So we're mixing these two concepts together here.
Here is a list of tuples.
This is a list called presidents that contains four tuples,
George Washington comma 1789 in parentheses--
that's how we indicate a tuple--
John Adams comma 1797, and so on and so on.
Each of these, each of George Washington 1789 and John Adams 1797 and so on,
that is a single tuple.
And then you see here that we have the commas at the end of those tuples
to indicate that all of those are items in the larger list called presidents.
Now, we can iterate over this list and do things with it.
So let's take a look at an example of how we might do that.
So up at the top right is our presidents list from just the previous slide.
And I can do the following.
For prez comma year in presidents.
So now, notice, I'm not just saying for x in range
where I'm using one iterator, I have two, prez comma year.
And if you look, you'll notice that that actually
matches what I have there in the presidents list.
I have a set of four tuples where each is arranged prez comma year.
Then I'm doing something weird.
Print in square bracket--
in curly brackets 1 curly bracket 0 took office dot format prez year.
What is happening?
This is actually just how the print function in Python
does what printf does in C. Instead of using percent s or percent c or percent
d, those format specifiers that we're used to from C,
here we use the dot format method, which we'll
talk about again in just a moment, at the end of the print function.
And we can specify the order in which we want those parameters to come out.
So the 1 and 0 there match like this.
Now granted, I wrote this deliberately to show you
that I could rearrange this list.
I also could have just swapped prez and year
and I wouldn't need the numbers at all.
If you leave them out it will just go left
to right through whatever the arguments are to format and plug those in left
to right just to fill in all of the curly brace emptiness's
that you have in the print function.
But here, I can also explicitly take them out of order if I want it.
So that's all I'm doing here.
I'm getting a list.
I'm getting a single tuple from this list
and I'm basically printing its elements in reverse order plugging them in.
So again, a contrived example, but I deliberately put
it here to show you the flexibility of the print function
and to introduced several concepts to you at once
because you also are probably going to see a lot of things
like this when you're doing research and trying to figure out
what Python functions to use.
You'll see a lot of unfamiliar things sort of blending together at once.
So I wanted to just kind of introduce it to you here as well.
But you can probably guess what this is going to do.
It'll print out the following.
In 1789 George Washington took office, In 1797 John Adams
took office, and so on.
It's going to iterate through the list and print out
each tuple plugging in its values.
And because I have the 1 and 0 there as opposed to just leaving them blank,
it swaps the order of them.
OK?
Another thing that we're sort of familiar with in C,
although it's not native, we had to build it ourselves,
is the concept of a dictionary.
Now dictionary is generally close in spirit to the concept of a hash table.
And remember that hash tables were not native to C
although they are native to a lot of programming languages.
We had to build it ourselves.
So it allows us to associate indexes with keys as opposed
to integers, which we had to do in C. So if we
wanted to have, for example, an array of something,
we could only refer to the elements of the array
by an index number, array square bracket 0, array square bracket 1, and so on.
In Python, we can now associate elements of a list
or elements in this case of a dictionary with keywords as opposed to integers.
So for example, here is a dictionary of pizzas.
So again, familiarize yourself with the different types
of brackets we're using.
So remember, in lists we have square brackets
to indicate the beginning and end of a list.
In tuples we use parentheses to indicate the beginning and end of a tuple.
In dictionaries we use curly braces to indicate
the beginning and end of a dictionary.
Inside of this pizza dictionary I have four key value pairs.
I associate the key cheese with the value 9,
I associate the key peperoni with the value 10, and so on.
Now, how might we want to work with this?
These again are out keys.
We use a colon to separate the key value pair.
And we specify-- and those are our values here in green.
I can change the value of different key value pairs in the dictionary as well.
So I could say pizzas square bracket cheese equals 8,
and now the key cheese is not associated with 9, it's associated with 8.
I could use the different keys in my dictionary
in Boolean expressions like this.
If pizza square bracket vegetables is less than 12 I could do something.
I can also add new keys to the dictionary,
key value pairs the dictionary, without having to do anything crazy.
Pizzas bacon, that key didn't exist before, equals 14.
Now we have a dictionary that has five different key value pairs in it.
Again, pretty straightforward to do.
But we've introduced a new problem.
If we don't have integer based indexes like we did in C,
how do we iterate through the dictionary?
We can't just iterate over the--
I guess we could maybe iterate over the keys alphabetically,
but then we would have to sort them alphabetically.
That feels kind of messy.
Fortunately, we can do this, and it's because
of the flexibility of the for loop.
And I pointed that out to you a little bit earlier
and I said we'd come back to talk about how the for loop was more flexible.
Let's see an example of this.
So the for loop is not just used to count from one number up to another.
We can also use it to iterate over the elements of a dictionary.
So instead of saying for x in range 500, which is going to do something
500 times, I can say for pie in pizzas.
That's pretty cool, right?
So what it's going to do there is it's going to use--
pie basically becomes every single key.
So cheese, bacon, vegetable, pepperoni, whatever else I had in there, that's
how we iterate over all of those keys in Python
without having the value of integers that we did previously.
So for example, here's the original pizzas dictionary
that we had just a moment ago.
If I say for pie in pizzas print pie, because again pie is substituting
for the keys, this is going to print out for me a list
of all of the keys in my dictionary.
So these are maybe the kinds of pizzas that I have available.
Or for pie comma price in pizzas dot items-- now
I have to specify pizzas items here to make it
so that it can iterate over all of the keys.
Excuse me, over all of the values.
I can iterate over all of the keys automatically in a dictionary.
But if I want to iterate over the values,
I have to transform the dictionary into a list.
In order to do that, I need to use the dot items
method to transform my dictionary into a list for purposes
of just iterating over this.
Then I can print out the price.
So in this case, I would print out 12, 10, 9, 11.
That's weird.
It didn't print them out in the order I specified
and that's kind of a side effect here with the dictionary.
You're not necessarily going to get your--
when you transform the dictionary into a list to iterate over it as we do here,
you're not guaranteed that that list is going to maintain its order.
Now, the keys and values will still be associated correctly,
if I wanted to print out both as we'll see in just a second.
But the order is not guaranteed anymore.
Now usually that's not going to be a problem.
Sometimes it might be, in which case you're just going
to have to use a list at the outset.
And there are, of course, ways around it.
Let's say I wanted to print both the key and the value.
It's very similar to what I just had before.
I'm still iterating over pie and price, and I'm still
transforming the pizzas dictionary into a list
temporarily so I can iterate over it.
And I'm using my print function again here
with now I'm not specifying 0 and 1.
I could, and specify 0 in the first one, 1 in the second one.
But I want to actually print the key first then the value.
I don't want to have to invert them so I don't have to plug in the ordering
that I did before when I was doing the presidents example,
iterating over all those tuples.

And this would print out, a whole Buffalo chicken pizza
costs $12, a whole cheese pizza costs $9.
Again, going through each element and getting the key value pair
and printing it out as I indicated.
So that's how I can iterate over an entire dictionary,
printing out all of its elements.
Again, with the caveat that it's not ordered,
so I'm not guaranteed to get them in exactly the same order I put them in.
But again, that trade off is probably going to be worth it most of the time.
So now we've seen a lot of examples of this.
How to interpolate variables similar to printf where
we would use percent substitution.
In Python, we've seen this one quite a few times.
There's also this one which would allow us to concatenate strings together.
So here, I'm not doing any interprolation,
but I'm plugging in the variable pie and the variable price,
transforming it into a string, because everything else here
is the string so I need to transform that number into a string
to make this work correctly.
So that's what the str function there does.
But this again would work.
So a whole cheese pizza costs dollars 9 turned into a string.
You might see this, which is actually really similar to you from printf
but it's deprecated in Python 3.
So you don't really want to use it even though it might be more familiar to you
because it's similar to printf.
So you might see it, but try and avoid using it because it is deprecated.
So again, Python is not just a main function
that we just run down the lines.
In fact, Python doesn't have a main function
by default. We have to explicitly force it
to have a main function if we want to.
But it does support functions more generally.
And we don't need to specify the return type of functions.
And we don't need to specify the data types of any parameters.
So you might recall from C that we had to specify like int square maybe
it took an integer as its input, so int square parentheses int x semicolon
or all this stuff we have going on.
We don't have to any of those data types.
We just have to specify the name of the function and any parameters
that it takes.
We introduce a function using the keyword def.
So basically, think about it as like defining the following function.
And because the interpreter reads from top to bottom,
we don't have to include our main function.
But if we want to include main because maybe we wrote our code such that
the stuff we want to execute first actually is maybe 200 lines
into our file-- we wrote other stuff up above,
maybe we're keeping our functions in alphabetical order or whatever else--
we can explicitly direct our program to start at the main function
by including this line at the very, very end of our Python file.
And this is just something to memorize.
If underscore underscore name underscore underscore equals equals
quote underscore underscore main underscore underscore quote colon
and then tab in main parentheses.
This is one of those things that you don't necessarily
have to use because you write your code such
that the first line is the first thing you want
to happen it's going to be fine anyway.
But if you write it out of order, this is
just one of those things you just have to memorize.
Sorry.
So defining a function, pretty straightforward.
Let's define the square of x like we just
did a second ago in C. Def square parentheses x colon return x times x.
Pretty straightforward.
I could also do this.
I could return x times times 2.
Well, actually this operator here is a built in, which did not have,
exponentiation operator.
So this is return x squared.
I could also be really convoluted and write my square function
by adding x to itself x times.
Doesn't really matter.
As long as the result is the same, it can be a black box
just like we talked about an out function video.
We don't necessarily care how the square function is defined,
as long as it does what we expect it to do.
As long as printing the square of 5 prints out 25.
All right, now here's something entirely different.
Let's talk about objects.
So objects we have not covered yet in CS50.
And Python is an object oriented programming language.
The closest thing we have to an object is a C structure.
So C structures, you may recall, have a number of fields in them.
We might call those fields, particularly in an object oriented context,
properties.
But those properties are never kind of able to just be on their own, right?
They're always bound up and tied into some definition of some C structure.
So if I define in C here, as I do at the top right, a car structure that
has two fields or two properties in it, year and model,
I might be able to say the following.
Struct car Herbie-- I'm declaring a new variable of type struct car called
Herbie--
and I'm saying Herbie dot year equals 1963,
Herbie dot model equals beetle, totally OK, right?
Because in each case where I'm using year and model,
I'm associating it with some structure of that data type, in this case Herbie.
But I could never say this.
Is not valid in C, at least with what we have here,
because year and model don't just kind of hang out on their own.
They're attached to what-- they're part of what it means to be a struct car.
So we always have to associate them with a struct car.
So that would not fly.
So that's sort of the--
that's sort of the analogy of object properties to C structure fields.
But objects, in addition to having properties, also have methods.
And you've heard me use that word a couple of times so far in this video.
Methods are basically functions that are inherent to what
it means to be an object.
You can't call that function just kind of out of the blue on anything.
You can only call that function on objects of that type,
on objects where that function means something.
So properties and methods don't ever stand on their own.
They're always part of what it means to be an object.
And because of this, objects become a lot more important.
If you have these properties and you have these methods
and they're always dependent on objects, that's where the term object oriented
comes from.
The object is the most important thing.
We don't pass objects into a function, we call methods on objects.
And that's the general syntax that you'll
see in a lot of object oriented programming languages, is some object,
and there is some method--
which again, is just another word for a function-- that
is associated with it that we are calling on that object.
We'll take a look at an example of this in just a moment.
Now objects are not necessarily generic.
We can actually create our own specific kinds of objects
just like we created our own specific types of structures in C.
And the way we do that is using the class keyword.
The class keyword introduces a new kind of object.
Every class, so every new kind of object you create,
requires an initialization function.
We didn't have to do this in C. But basically what it does--
and you'll also hear this term as a constructor,
you'll hear that commonly used in languages like C++ for example--
and basically what it does is it creates an object for you and it puts some--
it assigns the value of some properties automatically.
Remember that in Python we can only declare variables
by assigning them a value.
So basically, this is the analogous idea.
We are creating an object of a particular class,
and we are filling in all or many of the properties
of that object with some data.
Then, in addition to defining the properties of the object,
we also have to define functions or methods that can apply to the object.
Every method that we define inside of the class has at least one parameter,
and that parameter is canonically-- although you don't have to call it
this--
is called self, and basically all it is is a reference to the object
so that we can always know what object we are talking about.
So every function that you write, every method
that you write in a class to find some new kind of object,
will always have one more parameter than you think you need,
because the first parameter there will always be self.
Let's try and distill this into some actual code
so you can what we're doing here when we're talking about defining
a new kind of class, defining some methods,
and then we'll see how we can apply those methods to objects in that class.
So here is a very simple class called student.
So class Student with a capital S-- apparently this
means that I am now going to create-- whenever I want to create a new student
object I'll use that capital S Student keyword.
And I'm defining three functions.
The first is that constructor, that initialization function, which
is always called underscore underscore init underscore underscore.
Now, my Student apparently is going to have two properties.
They're going to have a name and an ID.
But because I'm defining a method inside of that class,
I always have to include that self parameter so that I always
know what object I am talking about or what object to being invoked here.
Inside of my initialization function I'm doing something pretty straightforward.
I'm just saying, self dot name equals name and self dot ID equals ID.
So I'm assigning the name and ID properties of the Student object
to be whatever I pass in here.
And then I have another function called changeID,
and apparently I use this to change the idea
of a student, the ID number of a student after I've already created them.
Because I'm assigning the ID when I initialize it, but here
apparently I've already created the Student object
and I'm going to change it.
So changeID takes two parameter, self against so I
know which Student, which capital S Student object I'm talking about,
and the ID number that I want to change them to.
And then I have a function called print, which takes just one parameter, self.
It's apparently not going to take anything else,
but still I always have to indicate the self parameter.
Always has to be part of any methods that you define for a class
that you create.
And apparently what I'm doing here is printing out self dot name and self dot
ID with a little dash between them.
That's what's happening there.
It's just some variable interpolation just like we saw before.
I'm just printing out self dot name dash self dot ID.
So what would happen here?
So I'm creating a new variable, a new object, called Jane.
And this is my initialization.
I'm calling the constructor function.
Jane equals Student with a capital S, again, that's the name of our class,
and I'm passing in tow values.
Jane, which I apparently want to map to self dot name, and 10.
So immediately after this, what would happened is
I would have a new student object called Jane,
and Jane's name field would be Jane in quotes,
and Jane's ID field would be 10.
So if I printed it out--
and you can actually take this code and recreate it in CS50 IDE
and see it for yourself-- if I then printed it out,
I would print out Jane space dash space 10.
Then if I executed Jane dot changeID 11, you
can probably guess what would happen because then when I print it again
it would print Jane space dash space 11.
So that's just some examples of creating-- of defining a class,
defining methods, assigning properties.
Again, all of this sort of is inherent to what
it means in an object-- to be working in an object oriented programming
language.
So even though this may be very unfamiliar and new,
especially coming from a language like C, this, if you go forward and do
object oriented programming in languages like Python,
like PHP, like JavaScript, or like many, many others,
this sort of notion of methods, properties,
and how we work with them is going to be really important to sort of synthesize.
So if you haven't noticed by now, good style
is really, really important in Python.
We don't have curly braces anymore which is great,
but we still need to be able to then indicate when a--
how an if block is delimited.
In C, we had an open curly brace, then we had some code,
we had some closed curly brace.
And it didn't really matter how things were styled in between.
I mean it mattered for somebody who is reading your code,
but it doesn't matter to the computer.
It does matter in Python.
Tabs and indentation are key in order to indicate what you intend for it to do.
So if I had an if block and I put a colon at the end of it
and I didn't indent the next line in, Python
wouldn't know that that line is supposed to be subject to that if condition.
So if you have not yet been in the habit of practicing good coding style,
now is the time to definitely reacquaint yourself with the CS50 style guide,
because if your code in Python is poorly styled,
it's probably not going to work.
Sorry about that.
So in C, we had the notion of including files
if we needed to get additional information from libraries,
for example like standard IO or CS50 dot h.
We can do the same thing in Python and C it was pound include.
In Python, we import, and instead of being called header files or libraries,
we generally call them modules.
But we could import CD50, and if we do we could then call some of the CD50
functions we might be familiar with.
We can do that by saying for example, CD50 dot get int parentheses.
And that would, just like get int does in C, get an integer from the user.
CS50 dot get float, dot get string, dot get char.
All those things that you've used in C, we can still use them in Python.
They just take a little longer to type.
We have to specify CS50 dot, because CS50 is basically, not exactly,
but it's basically a class where we're defining
a couple of different methods within it that we can then invoke.
You can, in addition to pre-writing your files in dot py files,
you can also just literally write Python using the Python interpreter
at the command line.
You can type in your IDE or in a lot of environments Python, and then hit Enter
and it will open a Python interpreter.
And you can literally write Python one line at a time.
In general though, if you're going to be writing more complex programs,
you're probably going to want to pre-write them and then load them
into the Python interpreter instead.
To invoke the Python interpreter, particular in CS50 IDE
but again more generally, Python space whatever the file you want to invoke
is, and then what will happen is the interpreter will open that file
and proceed one line at a time, top to bottom, executing your Python code.
And if you really want to make your Python programs look and run a lot more
like C programs-- for example, in C, once we compile a program into--
say we make hello, we then have dot slash hello--
we can include this line in red at the very top of our Python file.
And then we can execute the line in blue after we're done saving the file.
And then we can actually instead of typing Python and then
some whatever we want to call it dot pie, we could then just write dot
slash blah blah blah dot pie.
So again, I know that was a long video, there was a lot to cover in that one.
And we've really only just scratched the surface of introducing you to Python.
But it is an amazing language, incredibly flexible,
and it's a tool you're really going to want to put in your programmer's
toolbox if you're ever doing anything like data science or complex string
manipulation or really just familiarizing yourself with a language
that you can use both at the command line and in a web development context.
And we'll talk about how we can use Python in a web development context
in another video on flask.
I'm Doug Lloyd, this is CS50.
