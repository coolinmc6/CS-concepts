<a name='top'></a>
# CS50 - Intro to Computer Science

**Lectures**

- [Week 0](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-0)
- [Week 1](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-1)
- [Week 2](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-2)
- [Week 3](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-3)
- [Week 4](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-4)
- [Week 5](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-5)
- [Week 6](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-6)
- [Week 7](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-7)
- [Week 8](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-8)
- [Week 9](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-9)
- [Week 10](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-10)
- [Week 11](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-11)

**Lecture Notes**

|Lecture|Week|Lecture Notes Link|
|:---:|:---:|:---|
|0|0|[https://docs.cs50.net/2017/fall/notes/0/lecture0.html](https://docs.cs50.net/2017/fall/notes/0/lecture0.html)|
|1|1|[https://docs.cs50.net/2017/fall/notes/1/lecture1.html](https://docs.cs50.net/2017/fall/notes/1/lecture1.html)|
|2|1|[https://docs.cs50.net/2017/fall/notes/2/lecture2.html](https://docs.cs50.net/2017/fall/notes/2/lecture2.html)|
|3|2|[https://docs.cs50.net/2017/fall/notes/3/lecture3.html](https://docs.cs50.net/2017/fall/notes/3/lecture3.html)|
|4|3|[https://docs.cs50.net/2017/fall/notes/4/lecture4.html](https://docs.cs50.net/2017/fall/notes/4/lecture4.html)|
|5|4|[https://docs.cs50.net/2017/fall/notes/5/lecture5.html](https://docs.cs50.net/2017/fall/notes/5/lecture5.html)|
|6|5|[https://docs.cs50.net/2017/fall/notes/6/lecture6.html](https://docs.cs50.net/2017/fall/notes/6/lecture6.html)|
|7|6|[https://docs.cs50.net/2017/fall/notes/7/lecture7.html](https://docs.cs50.net/2017/fall/notes/7/lecture7.html)|
|8|6|[https://docs.cs50.net/2017/fall/notes/8/lecture8.html](https://docs.cs50.net/2017/fall/notes/8/lecture8.html)|
|9|7|[https://docs.cs50.net/2017/fall/notes/9/lecture9.html](https://docs.cs50.net/2017/fall/notes/9/lecture9.html)|
|10|8|[https://docs.cs50.net/2017/fall/notes/10/lecture10.html](https://docs.cs50.net/2017/fall/notes/10/lecture10.html)|
|11|9|[https://docs.cs50.net/2017/fall/notes/11/lecture11.html](https://docs.cs50.net/2017/fall/notes/11/lecture11.html)|
|12|11|[https://docs.cs50.net/2017/fall/notes/12/lecture12.html](https://docs.cs50.net/2017/fall/notes/12/lecture12.html)|

# Homework

|Week|Homework|Submitted|See the code|
|:---:|:---|:---:|:---|
|0|*none*|*n/a*||
|1|Mario|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset1/mario_less.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset1/mario_less.c)|
| |Cash|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset1/cash.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset1/cash.c)|
| |Caesar|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset2/caesar.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset2/caesar.c)|
| |Vigenere|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset2/vigenere.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset2/vigenere.c)|
|2|Music|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset3/helpers.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset3/helpers.c)|
|3|Whodunit|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset4/whodunit.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset4/whodunit.c)|
||Resize|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset4/resize.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset4/resize.c)|
||Recover|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset4/recover.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset4/recover.c)|
|4|Speller|||
|5|*none*|*n/a*||
|6|*none*|*n/a*||
|7<br>**pset 6**|Sentimental|||
|7<br>**pset 6**|Similarities|||
|8|Finance|||
|9|Mashup|||
|10|*none*|*n/a*||
|11|Final Project|||

# Next Steps
- go through and take notes on EACH of the shorts. I need to understand these concepts. Use the relevant
C-language ones to build your C-Notes.


# Week 0

**Lecture:** [https://www.youtube.com/watch?v=y62zj9ozPOM&list=PLhQjrBD2T3828ZVcVzEIhsHVgjANGZveu](https://www.youtube.com/watch?v=y62zj9ozPOM&list=PLhQjrBD2T3828ZVcVzEIhsHVgjANGZveu)

- phone book problem => keep splitting in half until you find Mike Smith

# Week 1

source code needs to be converted to machine code for the computer to read it
source code => compiler => machine code
IDE = Integrated Development Environment

`clang hello.c` => compile the code

`./a.out` => execute the code

```c
#include <stdio.h>

int main(void) 
{
	printf("hello, world\n");
}
```

- `clang -o hello hello.c` => compile the file and output a file called "hello"
- with C, you need to specify the kind of data you are creating (i.e. string, int, float, etc.)
- library => collection of functions
- if checking one character in C, you use single quotes; strings use double quotes

```c
#include <stdio.h>

// C is now made aware of the square function
int square(int n);

int main(void)
{
	// get_int is not from the C library
	int x = get_int("x: ");
	// printf("%i\n", x * x)
	printf("%i\n", square(x))
}

int square(int n)
{
	return n * n;
}
```

```c
int main(void)

int main(int argc, string argv[])
// argc => integer
// argv => array of strings

```

## Debugging

- help50, eprintf, debug50
- help50
	+ helps when your program is not compiling
	+ to use it: `help50 make example1`
- eprintf
	+ can show you where in the code a variable came from
	+ use `eprintf` in your code and then do `./eprintf`
- debug50
	+ `debug50 ./debug1`

## Arrays
- are a fundamential data structure
- We use arrays to hold values of the same type at contiguous memory locations
- arrays have been partitioned into small, identically sized blocks called elements
- each black can store a certain amount of data
- all of the same data type (int or char)
- and which can be accessed with an index number
- first index is 0
- C will not prevent you from going outside of the bounds of your array but you will get a
segmentation fault
- Array declaration:
	+ `type name[size]`
	+ the `type` is what kind of variable each element of the array will be
	+ the `name` is what you want to call your array
	+ the `size` is how many elements you would like your array to hold
	+ Examples:
		* `int studen_grades[40]`
		* `double menu_prices[8]`
- if you think of a single element of an array of type `data-type` the same as you would any other
variable of type `data-type`, then all the familiar operations make sense

```c
bool truthtable[10]

if(truthtable[7] == true)
{
	printf("TRUE\n");
}
```

- You can declare and initialize an array simultaneously:

```c
// instantiation syntax
bool truthtable[3] = { false, true, true };

// individual element syntax
bool truthtable[3];
truthtable[0] = false;
truthtable[1] = true;
truthtable[2] = true;
```

- Arrays can also have multiple dimensions

```c
bool battleship[10][10];
```
- in memory, it's really just a 100-element array
- we cannot assign one array to another array; we'd have to copy one array into the other

```c
int foo[5] = {1, 2, 3, 4, 5};
int bar[5];

for(int j = 0; j < 5; j++)
{
    bar[j] = foo[j];
}
```
- to pass something by value means we are copying the variable
- Arrays are passed by reference. The callee receives the actual array, **NOT** a copy of it

## Command Line Arguments

- To collect so called command-line arguments from the user, declare main as:
	- `int main(int argc, string argv[])`
	- argc = argument count
	- argv = argument vector
* argc is an integer and will store the number of command line arguments the user typed in
	- `./greedy` => argc = 1
	- `./greedy 1024 cs50` => argc = 3
* argv (argument vector)
	- this array of strings stores, one string per element, the actual text the user typed at the
	command-line when the program was executed
	- the first element of argv is always found at argv[0]

|argv indices|argv contents|comments|
|:---:|:---:|:---|
|argv[0]|"./greedy"||
|argv[1]|"1024"|notice that it is captured as a **string**, not an int<br>We will need to convert this to an int|
|argv[2]|"cs50"||

## Magic Numbers

- this allows you to declare, essentially, a global variable that can't be changed.
- when the code is compiled, it goes through the program and replaces all instances of that
constant with the number, string, etc.
- if `#include` is similar to copy/paste, `#define` is analagous to find/replace

```c
// define NAME REPLACEMENT(value)
#define PI 3.14159265
#define DECK_SIZE 52
#define COURSE "CS50"
```

# Week 2

## Music Homework Notes
- white keys are the non-sharp keys
- accidentals
	+ sharp = #
	+ flat = b
- C# = Db
- the piano is divided into octaves. The middle octave is Octave 4
- D4 = the D key in the 4th Octave
- C starts the Octaves so it would go from C4-D4-E4-F4-G4-A4-B4-C5
- **bday**
	+ using the sheet music
	+ figure out which notes are being played
	+ write down the ASCII representation in the bday.txt
	+ C4@1/8 => C, fourth octave, eighth note
	+ C#4@1/8 => C#, fourth octave, eighth note
	+ blank line means a resst for 1/8th note
- **helpers.c**
	+ Write three functions:
		* is_reset
		* duration
		* frequency
	+ is_rest
	+ duration
		* `int duration(string fraction)`
		* takes in a fraction as a string and output a whole number representing how many eight notes
		* 1/8 => 1
		* 1/4 => 2
		* 3/8 => 3
		* 1/2 => 4
	+ frequency
		* * `int frequency(string note)`
		* parse the string into a note and its octave => A#4 -> separate into A# and Octave 4
		* calculate the frequency of the note in the given octave
		* return the frequency
		* Frequencies 
			* A4 = 440 Hz
			* Every semitone up => frequency * 2 ^ 1/12
			* Every semitone down => frequency / 2 ^ 1/12
			* if moving two up => f * 2 ^ **2**/12
			* sounds like I will essentially just need to figure out out how many semitones away from A4 I am
			+ A5 = 880 Hz = 440 * 2 ^ 12/12 = 440 * 2 ^ 1 = 440 * 2

## Computational Complexity
- when we talk about about the complexity of an algorithm, we generally reger to the worst-case scenario
	+ this is **Big O**
- best case scenario is **Big Omega**
- We can measure how much it takes up (in resources) in terms of time or memory. This measure is *f(n)*
- Computation Complexity

|Big O|Time|Description
|O(1)|constant time|Always takes a single operation in the worst case|
|O(log n)|logarithmic time|Always takes *n* operations in the worst case|
|O(n)|linear time||
|O(n log n|linearithmic time||
|O(n^2|quadratic time||
|O(n ^C|polynomial time||
|O(c^n|exponential time||
|O(n!)|factorial time||
|O(infinity)|infinite time||

## Selection Sort
- Find the smallest unsorted element and add it to the end of a sorted list
- In pseudocode (repeat this until sorted):
	+ Search the unsorted part of the data to find the smallest value
	+ swap the smallest found value with the first element of the unsorted part
- Worst-case scenario: iterate over each of the n elements (to find the smallest unsorted element) and we must repeat this process *n* times, since only one element gets sorted on each pass
- Best-case scenario: exactly the same! There's no way to guarantee the array is sorted until we go through
the process for all of the elements
- Worst Case: O(n^2)
- Best Case: Omega (n^2)

## Bubble Sort
- In pseudocode:
	+ set swap counter to a non-zero value (i.e. -1; otherwise it won't run once)
	+ repeat until the swap counter is 0:
		* reset swap counter to 0;
		* look at each adjacent pair; if not in order, swap them and add one to the swap counter
- Worst-case scenario: array is in reverse order
- Best-case: array is already perfectly sorted and make no swaps on the first pass
- Worst Case: O(n^2)
- Best Case: Omega (n)

## Insertion Sort
- build your sorted array in place, shifting elements out of the way if necesary to make room as you go
- In pseudocode:
	+ call the first element of the array "sorted"
	+ Repeat until all elements are sorted:
		* Look at the next unsorted element. Insert into the sorted portion by shifting the requisite number
		of elements
- we didn't have to go back and forth across the array
- Worst case scenario: array is in reverse order; we have to shift *n*elements *n* positions each time we make an insertion
- Best case scenario: the array is already perfectly sorted and we simply keep moving the line between "unsorted" and "sorted" as we examine each element
- Worst Case: O(n^2)
- Best Case: Omega (n)

## Merge Sort
- Merge sort leverages recursion
- Break arrays into arrays of one element that are "sorted"
- Essentially: sort the left half, sort the right half, merge the two halves
- Worst-case scenario: split n elements up and then recombine them, effectively doubling the sorted
subarrays as we build them up
- Best case scenario: The array is already perfectly sorted but we will still have to split and recombine it back together
- Worst Case: O(n log n)
- Best Case: Omega (n log n)

## Linear Search
- itrate across the array from left to right, searching for a specified element
- In pseudocode:
	+ repeat, starting at first element:
		* is the first element is what you're looking for? Yes, stop;
		* If No, move to the next element
- Worst-case scenario: we look through entire array of n elements (it's the last item or it's not in the array)
- Best-case scenario: it's the first item
- Worst Case: O(n)
- Best Case: Omega (1)

## Binary Search
- This is divide and conquer => we can only do this if the array is **sorted**
- In pseudocode:
	+ Repeat until the (sub)array is of size 0:
		* calculate midpoint
		* if target, then stop
		* if target < midpoint, move start point to left of that and then divide in half again
- if element does not exist, end point will be lower than start point creating a subarray of 0
- Worst case scenario: we have to divide a list of n elements repeatedly in half either because that's where
the element is or it's not in the array
- Best case scenario: target element is at midpoint of full array
- Worst Case: O(log n)
- Best Case: Omega (1)

## Recursion
- A recursive funciton is one that, as part of its execution, calls itself
- `fact(n) = n * fact(n-1)`
- Every recursive function has two cases that could apply, given any input:
	+ the **base case**, which when triggered will terminate the recursive function
	+ the **recursive case**, which is where the function calls itself

```c
int fact(int n)
{
	if (n == 1) 
	{
		return 1;
	}
	else
	{
		return n * fact(n-1);
	}

}

```

- that can be slimmed down in C if a conditional only has a return line then:

```c
int fact(int n)
{
	if (n == 1) 
		return 1;
	else
		return n * fact(n-1);
}

```

- In general, but not always, recursive functions replace loops in non-recursive functions
- It's possible to have more than one base case
- The Collatz Conjecture applies to positive integers and speculates that it is always possible to get back to 1:
	+ if n is 1, stop
	+ Otherwise, if n is even, repeat this process on n/2
	+ Otherwise, if n is odd, repeat this process on 3n + 1

## Algorithms Summary

|Algorithm Name|Basic Concept|Big O|Omega|
|:---:|:---|:---:|:---:|
|Selection Sort|Find the smallest unsorted element in an array and swap it with first unsorted element in that array|n^2|n^2|
|Bubble Sort|Swap adjacent pairs of elements if they are out of order, effecting "bubbling" larger elements to the right and smaller ones to the left|n^2|n|
|Insertion Sort|Go through the array one time from left to right, shifting elements as necessary to insert each element into its correct place|n^2|n|
|Merge Sort Sort|Split the full array into subarrays, then merge those subarrays back together in the correct order|n log n|n log n|
|Linear Search|Iterate across the array from left-to-right, trying to find the target element|n|1|
|Binary Search|Given a sorted array, divide and conquer by systematically elminating half of the remaining elements in the search for the target|log n|1|

## GDB (the GNU Debugger)
- to kick things off with GDB:
	+ `gdb <program name>`
	+ that will pull up the GDB environment. The next two major commands you'll likely use (in order) are:
		* `b [function name, line number]` or `break [function name, line number]`
			- program will run uninterrupted until it encounters the function with that name or hits that line
			number, at which point it will pause and wait further instructions
		* `r [command-line arguments]`
			- runs program with the command line arguments provided, if any
- Other commands:

|command|actions|
|:---:|:---:|
|`n`|will step forward one block of code|
|`s`|will step forward one line of code|
|`p [variable]`|prints out the value of the variable given|
|`info locals`|prints out the values of all local variables|
|`bt`|show you what series of function calls led you to the current point in the program|
|`q`|quits GDB|


# Week 3

## Call Stacks
- when you call a function, the system sets aside space in memory for that function to do its necessary work. These
chunks of memory are called **stack frames** or **function frames**
- More than one function's stack frame may exist in memory at a given time. If `main()` calls `move()`, which then
calls `direction()`, all three have open frames but they don't all have active frames
- only the frame on the top of the stack is "active"
- Frames are arranged in a **stack**. The frame for the most recently called function is always on top
- When a new frame is called, it's pushed onto the top of the stack and becomes *active*
- When a function finishes its work, its frame is popped off the stack and the frame below it becomes the new, 
active function on top of the stack. This function immediately picks up where it left off

## File Pointers
- the ability to read data from and write data to files is the primary means of storing **persistent data**, 
data that does not disappear when your program stops running
- the abstraction of files that C provides is implemented in a data structure known as a FILE
	+ almost universally when working with files, we will be using pointers to them, `FILE*`
- The file manupulations functions all live in `stdio.h`
	+ all of them accept `FILE*` as one of their parameters, except for `fopen`
- `fopen()`
	+ opens a file and returns a file pointer to it
	+ always check the return value to make sure you don't get back NULL
	+ `FILE* ptr = fopen(<filename>, <operation>);`
	+ example: `FILE* ptr = fopen("file1.txt", "r");`
		* "r" = read
		* "w" = write (risks overwriting the file)
		* "a" = append (add to the file)
- `fclose()`
	+ closes the file pointed to by the given file pointer
	+ `fclose(ptr1)`
- `fgetc()`
	+ reads and returns the next character from the file pointed to
	+ Note: the operation of the file pointer passed in as a parameter must be "r" for read, or you'll
	get an error
	+ `char ch = fgetc(<file pointer>);`
- the ability to get single characters from files, if wrapped in a loop, means we could read all the 
characters from a file and print them to the screen, one-by-one:

```c
char ch;
while((ch = fgetc(ptr)) != EOF)	// EOF is a special word indicating end-of-file
	printf("%c", ch);
```
- `fputc()`
	+ writes or appends the specified character to the pointed-to file
	+ Note: the operation of the file pointer passed in as a parameter must be "w" for write or "a" for
	append or you'll get an error
	+ `fputc('A', ptr2);`

```c
char ch;
while((ch = fgetc(ptr)) != EOF)
	fputc(ch, ptr2);
```
  - this is essentially the `cp` command in Linux command line
- `fread()`
	+ reads <qty> units of size <size> from the file pointed to and stores them in memory in a buffer
	(usually an array) pointed to by <buffer>
	+ Note: the operation of the file pointer passed in as a parameter must be "r" for read or you'll
	get an error
	+ Examples:
	
```c
int arr[10]
fread(arr, sizeof(int), 10, ptr);

// We could also dynamically allocate a buffer using malloc.
// When dynamically allocating memory, we're saving it on the heap, not the stack
double* arr2 = malloc(sizeof(double) * 80);
fread(arr2, sizeof(double), 80, ptr);

/*
- We can also treat `fread` just like a call to `fgetc`.
- In this case, we're just trying to get one character from the file and we don't need an array to hold a character,
we can just store it in a character variable.
- The catch, though, is that when we just have a variable, we need to pass in the address of that variable
because recall that the first argument to fread is a pointer to the location and memory where we want to store the information.
- Hence the &c as opposed to just c
*/
char c;
fread(&c, sizeof(char), 1, ptr);
```

- `fwrite()`
	+ writes <qty> units of size <size> to the file pointed to by reading them from a buffer (usually an array)
	pointed to by <buffer>
	+ Note: the operation of the file pointer passed in as a parameter must be "w" for write or "a" for append
	or you'll get an error


## Pointers
- Pointers provide an alternative way to pass data between functions
	+ recall that we have (up to this point) passed all data by value, with one exception
	+ when we pass data vy value, we only pass a copy of that data
- If we use pointers instead, we have the power to pass the variable itself
	+ that means that a change that is made in one function **can** impact what happens in a different function
	+ previously, that wasn't possible!
- Pointers are related to memory
- Every file on your computers lives on your disk drive, either a hard disk drive (HDD) or a solid state drive (SSD)
disk drives are just storage space; we can't directly work there. Manipulation and use of data can only take place in
RAM, so we have to move data there
- Memory is basically a huge array of 8-bit wide bytes (512 MB, 1GB. 2GB. 4GB)

|Data Type|Size (in bytes)|
|:---:|:---:|
|int|4|
|char|1|
|float|4|
|double|8|
|long long|8|
|string|???|

- memory is just a big array of byte-sized cells
- every element of that array has an address
- arrays are useful for not just **storage** of information but also for *random access* (accessing
individual elements of the array by indicating which index location we want)
- every location in memory has an address
- string must end with `\0` so if there are 5 characters, we need a size of 6
- A pointer is nothing more than an address
- Pointers are addresses to memory where variables live


## Dynamic Memory Allocation


## Hexadecimal



## HOMEWORK: Whodunit
- take BMP clue
- Items To Do:
	+ open file
	+ update header's info for outfile
	+ read clue's scanline, pixel by pixel
	+ change pixel's color as necessary
	+ write verdict's scanline, pixel by pixel
- `copy.c`
	+ already does a lot of things: opens a file, updates header, reads each scanline, writes each pixel in the output file
- Items to do:
	+ `cp copy.c whodunit.c`
- BITMAPINFOHEADER
	+ biWidth (bitmap info Width)
	+ biHeight
	+ biSizeImage
- BITMAPFILEHEADER
	+ bfSize
		* total size of file (in bytes)
	+ bf.bfSize = bi.biSizeImage + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)
- fread(data, size, number, inptr)
	+ data - pointer to a struct that will contain the bytes you're reading
	+ size - size of each element to read
	+ number - number of elements to read
	+ inptr - FILE * (pointer) to read from
- pixel color - represented by 3 bytes
- RGBTRIPLE scruct
	+ a struct to represent pixels
	+ here is a green pixel:

```c
RGBTRIPLE triple;
triple.rgbtBlue = 0x00;
triple.rgbtGreen = 0xff;
triple.rgbtRed = 0x00;
```

- One way to decode it would be to turn all pure red into white
- writing files
	+ `fwrite(data, size, number, outptr)`
- padding
	+ each pixel is 3 bytes
	+ length of each scanline must be 4 bytes
	+ if the number of pixels isn't 4, we must add some padding (0x00)
	+ each scanline must be a multiple of 4:
		* Ex #1: scanline has 4 RGBtriple's => no padding needed (4 * 3 = 12; 12 is a multiple of 4)
		* Ex #2: scanline has 5 RGBtriple's => 1 byte of padding required (5 * 3 = 15; plus 1 is 16)
			- one byte of padding is 0x00
		* Ex #3: scanline has 6 RGBtriple's => 2 bytes of padding required (6 * 3 = 18; plus 2 is 20)
	+ We don't have to come up with the formula, the padding formula is given
- write padding
	+ `fputc(chr, outptr)`
		* chr => char to write
		* outptr => FILE * to write to
- file position indicator
	+ `fseek(inptr, offset, from);`

## Resize

- bitmaps are just an arrangement of bytes, it's all about how we read them
- Because we are changing the size of the file we have to change the header file
- BITMAPINFOHEADER
	+ biWidth (width of image in pixels)
	+ biHeight (height of image in pixels)
	+ biSizeImage (total size of image in bytes) => includes pixels and padding
- What's changing when scaling by n?
	+ bi.biWidth => bi.biWidth * n
	+ bi.biHeight => bi.biHeight * n
	+ bi.biSizeImage => ((biWidth * n) * sizeof(RGBTRIPLE) + padding) * abs(biHeight * n)
	+ bf.bfSize => sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + biSizeImage
- Resize horizontally
	+ write each pixel twice!
- padding
	+ to write padding, we need `fputc()`
- fseek() needed
- pseudocode:
	+ for each row:
		* for each pixel
			- write to array n times
		* for n times
			- write array to outfile
			- write outfile padding
		* skip over infile padding

## Recover

- TODO
	+ open memory card file
		* fopen
		* check if its null
		* we start at the beginning and check the first few bytes to see if it is a JPEG. If not, we can then
		skip to the next block of 512 bytes
		* CM => right away, I am unsure about how to read the bytes or the proper struct I should be using. The
		looping through the bytes seems easy; it's the comparison of those bytes is what seems hard
	+ find beginning of JPEG
		* once we find a JPEG, we just write 512 bytes at a time until we reach the end of the JPEG
	+ open a new JPEG write 512 bytes until new JPEG is found
	+ 
	+ detect end of file

- JPEGs
	+ each JPEG starts with a distinct header
		* first three bytes: 0xff 0xd8 0xff
		* last byte: 0xe0 0xe1 0xe2 ... 0xef
	+ stored side-by-side on the memory card
	+ each block is 512 bytes
	+ One recommendation is the bitwise and operator:
		* `if (buffer[0] == 0xff && buffer[1] == 0xd8 && buffer[2] == 0xff && (buffer[3] & 0xf0) == 0xe0)`
		* filenames need to be formated as follows: ###.jpg
		* named in the order in which they are found, starting at 000
	+ making a new JPEG
		* `sprintf(filename, "%03i.jpg", 2);`
			- filename: char array to store the resultant string
			- looks like this returns something with 3 places whatever the ith int is where 2 is the
			number we want in there ====> 002.jpg
		- FILE *img = fopen(filename, "w");
- Reading files
	+ fread(data, size, number, inptr)
	+ data: pointer to a **struct** that will contain the bytes you're reading
	+ size: size of each element to read
		* sizeof
	+ number: number of elements to read
	+ inptr: FILE * to read from
	+ fread returns the number of elements successfully read
		* `fread(buffer, 1, 512, raw_file)` OR
		* `fread(buffer, 512, 1, raw_file)`
- Writing files
	+ `fwrite(data, size, number, outptr);`
	+ data - pointer to the struct that contains the bytes you're reading from
	+ size
	+ number
	+ outptr: FILE * to write to
- End of file?
	+ fread returns the number of elements successfully read
		* `fread(buffer, 1, 512, raw_file)` OR
		* `fread(buffer, 512, 1, raw_file)`
	+ `fread(data, size, number, inptr);`
		* return how many items of size `size` were read (and ideally, it returns a number)
		* use directly in a condition!
- pseudocode
	+ open card file
	+ repeat until end of card
		* read 512 bytes into a buffer
		* start of a new JPEG?
			- yes ->
			- no ->
		* already found a JPEG?
			- no ->
			- yes ->
	+ close any remaining files

[back to top](#top)

# Week 4
- lecture 5

## Structures
- structures provide a way to unify several variables of different dyptes into a single, new variable
type which can be assigned to its own type name
- we structures (structs) to group together elements of a variety of data types that have a logical
connection

```c
// Defining a Struct
struct car
{
	int year;
	char model[10];
	char plate[7];
	int odometer;
	double engine_size;
}

```
  - `struct` => indicates that we are creating a new struct
  - `car` => name of the struct
  - inside the curly braces are the fields of my struct
  - each field (or member) of the struct must end with a semicolon
  	+ *similar to the **property** of a JS object*
- Once we have a defined structure, which we typically do in separate .h files or atop our programs outside
of any funcitons
- that means we create variables of that type using the familiar syntax
- we access those fields (also known as members) using the dot operator (.)

```c
// variable declaration
struct car mycar;

// field accessing
mycar.year = 2011;
mycar.plate = "CS50";
mycar.odometer = 50505;
```

- Structures, like variables of all other data types, do not need to be created on the stack. We can 
dynamically allocate structure at run time if our program requires it
- In order to access the fields of our structures in that situation, we first need to dereference the
pointer to the structure, and then we can access its fields

```c
// variable declaration
struct car *mycar = malloc(sizeof(struct car));

// field accessing
(*mycar).year = 2011;
(*mycar).plate = "CS50";
(*mycar).odometer = 50505;
```
- Instead of declaring mycar on the stack `struct car mycar`, I can do the above. That returns a pointer to the
block of memory. As a refresher, **malloc** allocates the requested memory of a particular size and returns a
pointer to it.
- To access the fields, I first dereference my car using the dereference operator, `*mycar`, and then after I
dereference, I use the dot operator to access the various fields of mycar.
- THe arrow operator allows us to trim that down

```c
// variable declaration
struct car *mycar = malloc(sizeof(struct car));

// field accessing
mycar->year = 2011;
mycar->plate = "CS50";
mycar->odometer = 50505;
```
- what is happening is that first, we are dereferencing `mycar` (which is a pointer here), we then access the fields.
- **So what is dereferencing?**
	+ "Dereferencing a pointer means getting the value that is stored in the memory location pointed by the pointer"

## Speller
- TODO
	+ calls `load` on the dictionary file
		* dictionary contains valid words, one per line
	+ calls `check` on each word in the text file and prints all misspelled words
	+ calls `size` to determine the number of words in dictionary
	+ calls `unload` to free up memory
- `check`
	+ case-insensitivity
	+ assume strings with only alphabetical characters and/or apostrophes
	+ if the word exists, it can be found in the hash table
	+ which bucket would the word be in?
		* `hashtable[hash(word)]`
	+ search in that linked list
		* `strcasecmp`
- 

[back to top](#top)

# Week 5
- lecture 6

[back to top](#top)

# Week 6
- lectures 7 & 8

[back to top](#top)

# Week 7

[back to top](#top)

# Week 8

[back to top](#top)

# Week 9

[back to top](#top)

# Week 10

[back to top](#top)

# Week 11

[back to top](#top)