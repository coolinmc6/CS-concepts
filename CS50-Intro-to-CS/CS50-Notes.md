<a name='top'></a>
# CS50 - Intro to Computer Science

**Lectures**

- [Week 0](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-0)
- [Week 1](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-1)
- [Week 2](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-2)
- [Week 3](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-3)
- [Week 4](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-4)
- [Week 5](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-5)
- [Week 6](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-6)
- [Week 7](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-7)
- [Week 8](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-8)
- [Week 9](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-9)
- [Week 10](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-10)
- [Week 11](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-11)

**Lecture Notes**

|Lecture|Week|Lecture Notes Link|
|:---:|:---:|:---|
|0|0|[https://docs.cs50.net/2017/fall/notes/0/lecture0.html](https://docs.cs50.net/2017/fall/notes/0/lecture0.html)|
|1|1|[https://docs.cs50.net/2017/fall/notes/1/lecture1.html](https://docs.cs50.net/2017/fall/notes/1/lecture1.html)|
|2|1|[https://docs.cs50.net/2017/fall/notes/2/lecture2.html](https://docs.cs50.net/2017/fall/notes/2/lecture2.html)|
|3|2|[https://docs.cs50.net/2017/fall/notes/3/lecture3.html](https://docs.cs50.net/2017/fall/notes/3/lecture3.html)|
|4|3|[https://docs.cs50.net/2017/fall/notes/4/lecture4.html](https://docs.cs50.net/2017/fall/notes/4/lecture4.html)|
|5|4|[https://docs.cs50.net/2017/fall/notes/5/lecture5.html](https://docs.cs50.net/2017/fall/notes/5/lecture5.html)|
|6|5|[https://docs.cs50.net/2017/fall/notes/6/lecture6.html](https://docs.cs50.net/2017/fall/notes/6/lecture6.html)|
|7|6|[https://docs.cs50.net/2017/fall/notes/7/lecture7.html](https://docs.cs50.net/2017/fall/notes/7/lecture7.html)|
|8|6|[https://docs.cs50.net/2017/fall/notes/8/lecture8.html](https://docs.cs50.net/2017/fall/notes/8/lecture8.html)|
|9|7|[https://docs.cs50.net/2017/fall/notes/9/lecture9.html](https://docs.cs50.net/2017/fall/notes/9/lecture9.html)|
|10|8|[https://docs.cs50.net/2017/fall/notes/10/lecture10.html](https://docs.cs50.net/2017/fall/notes/10/lecture10.html)|
|11|9|[https://docs.cs50.net/2017/fall/notes/11/lecture11.html](https://docs.cs50.net/2017/fall/notes/11/lecture11.html)|
|12|11|[https://docs.cs50.net/2017/fall/notes/12/lecture12.html](https://docs.cs50.net/2017/fall/notes/12/lecture12.html)|

# Homework

|Week|Homework|Submitted|See the code|
|:---:|:---|:---:|:---|
|0|*none*|*n/a*||
|1|Mario|yes|[mario_less.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset1/mario_less.c)|
| |Cash|yes|[cash.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset1/cash.c)|
| |Caesar|yes|[caesar.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset2/caesar.c)|
| |Vigenere|yes|[vigenere.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset2/vigenere.c)|
|2|Music|yes|[helpers.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset3/helpers.c)|
|3|Whodunit|yes|[whodunit.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset4/whodunit.c)|
||Resize|yes|[resize.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset4/resize.c)|
||Recover|yes|[recover.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset4/recover.c)|
|4|Speller|no|[speller/dictionary.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset5/speller/dictionary.c)|
|5|*none*|*n/a*||
|6|*none*|*n/a*||
|7<br>**pset 6**|Sentimental|||
|7<br>**pset 6**|Similarities|||
|8|Finance|||
|9|Mashup|||
|10|*none*|*n/a*||
|11|Final Project|||

# Next Steps
- go through and take notes on EACH of the shorts. I need to understand these concepts. Use the relevant
C-language ones to build your C-Notes.

# Week 0

**Lecture:** [https://www.youtube.com/watch?v=y62zj9ozPOM&list=PLhQjrBD2T3828ZVcVzEIhsHVgjANGZveu](https://www.youtube.com/watch?v=y62zj9ozPOM&list=PLhQjrBD2T3828ZVcVzEIhsHVgjANGZveu)

- phone book problem => keep splitting in half until you find Mike Smith

# Week 1

source code needs to be converted to machine code for the computer to read it
source code => compiler => machine code
IDE = Integrated Development Environment

`clang hello.c` => compile the code

`./a.out` => execute the code

```c
#include <stdio.h>

int main(void) 
{
	printf("hello, world\n");
}
```

- `clang -o hello hello.c` => compile the file and output a file called "hello"
- with C, you need to specify the kind of data you are creating (i.e. string, int, float, etc.)
- library => collection of functions
- if checking one character in C, you use single quotes; strings use double quotes

```c
#include <stdio.h>

// C is now made aware of the square function
int square(int n);

int main(void)
{
	// get_int is not from the C library
	int x = get_int("x: ");
	// printf("%i\n", x * x)
	printf("%i\n", square(x))
}

int square(int n)
{
	return n * n;
}
```

```c
int main(void)

int main(int argc, string argv[])
// argc => integer
// argv => array of strings

```

## Debugging

- help50, eprintf, debug50
- help50
	+ helps when your program is not compiling
	+ to use it: `help50 make example1`
- eprintf
	+ can show you where in the code a variable came from
	+ use `eprintf` in your code and then do `./eprintf`
- debug50
	+ `debug50 ./debug1`

## Arrays
- are a fundamential data structure
- We use arrays to hold values of the same type at contiguous memory locations
- arrays have been partitioned into small, identically sized blocks called elements
- each black can store a certain amount of data
- all of the same data type (int or char)
- and which can be accessed with an index number
- first index is 0
- C will not prevent you from going outside of the bounds of your array but you will get a
segmentation fault
- Array declaration:
	+ `type name[size]`
	+ the `type` is what kind of variable each element of the array will be
	+ the `name` is what you want to call your array
	+ the `size` is how many elements you would like your array to hold
	+ Examples:
		* `int studen_grades[40]`
		* `double menu_prices[8]`
- if you think of a single element of an array of type `data-type` the same as you would any other
variable of type `data-type`, then all the familiar operations make sense

```c
bool truthtable[10]

if(truthtable[7] == true)
{
	printf("TRUE\n");
}
```

- You can declare and initialize an array simultaneously:

```c
// instantiation syntax
bool truthtable[3] = { false, true, true };

// individual element syntax
bool truthtable[3];
truthtable[0] = false;
truthtable[1] = true;
truthtable[2] = true;
```

- Arrays can also have multiple dimensions

```c
bool battleship[10][10];
```
- in memory, it's really just a 100-element array
- we cannot assign one array to another array; we'd have to copy one array into the other

```c
int foo[5] = {1, 2, 3, 4, 5};
int bar[5];

for(int j = 0; j < 5; j++)
{
    bar[j] = foo[j];
}
```
- to pass something by value means we are copying the variable
- Arrays are passed by reference. The callee receives the actual array, **NOT** a copy of it

## Command Line Arguments

- To collect so called command-line arguments from the user, declare main as:
	- `int main(int argc, string argv[])`
	- argc = argument count
	- argv = argument vector
* argc is an integer and will store the number of command line arguments the user typed in
	- `./greedy` => argc = 1
	- `./greedy 1024 cs50` => argc = 3
* argv (argument vector)
	- this array of strings stores, one string per element, the actual text the user typed at the
	command-line when the program was executed
	- the first element of argv is always found at argv[0]

|argv indices|argv contents|comments|
|:---:|:---:|:---|
|argv[0]|"./greedy"||
|argv[1]|"1024"|notice that it is captured as a **string**, not an int<br>We will need to convert this to an int|
|argv[2]|"cs50"||

## Magic Numbers

- this allows you to declare, essentially, a global variable that can't be changed.
- when the code is compiled, it goes through the program and replaces all instances of that
constant with the number, string, etc.
- if `#include` is similar to copy/paste, `#define` is analagous to find/replace

```c
// define NAME REPLACEMENT(value)
#define PI 3.14159265
#define DECK_SIZE 52
#define COURSE "CS50"
```

# Week 2

## Music Homework Notes
- white keys are the non-sharp keys
- accidentals
	+ sharp = #
	+ flat = b
- C# = Db
- the piano is divided into octaves. The middle octave is Octave 4
- D4 = the D key in the 4th Octave
- C starts the Octaves so it would go from C4-D4-E4-F4-G4-A4-B4-C5
- **bday**
	+ using the sheet music
	+ figure out which notes are being played
	+ write down the ASCII representation in the bday.txt
	+ C4@1/8 => C, fourth octave, eighth note
	+ C#4@1/8 => C#, fourth octave, eighth note
	+ blank line means a resst for 1/8th note
- **helpers.c**
	+ Write three functions:
		* is_reset
		* duration
		* frequency
	+ is_rest
	+ duration
		* `int duration(string fraction)`
		* takes in a fraction as a string and output a whole number representing how many eight notes
		* 1/8 => 1
		* 1/4 => 2
		* 3/8 => 3
		* 1/2 => 4
	+ frequency
		* * `int frequency(string note)`
		* parse the string into a note and its octave => A#4 -> separate into A# and Octave 4
		* calculate the frequency of the note in the given octave
		* return the frequency
		* Frequencies 
			* A4 = 440 Hz
			* Every semitone up => frequency * 2 ^ 1/12
			* Every semitone down => frequency / 2 ^ 1/12
			* if moving two up => f * 2 ^ **2**/12
			* sounds like I will essentially just need to figure out out how many semitones away from A4 I am
			+ A5 = 880 Hz = 440 * 2 ^ 12/12 = 440 * 2 ^ 1 = 440 * 2

## Computational Complexity
- when we talk about about the complexity of an algorithm, we generally reger to the worst-case scenario
	+ this is **Big O**
- best case scenario is **Big Omega**
- We can measure how much it takes up (in resources) in terms of time or memory. This measure is *f(n)*
- Computation Complexity

|Big O|Time|Description
|O(1)|constant time|Always takes a single operation in the worst case|
|O(log n)|logarithmic time|Always takes *n* operations in the worst case|
|O(n)|linear time||
|O(n log n|linearithmic time||
|O(n^2|quadratic time||
|O(n ^C|polynomial time||
|O(c^n|exponential time||
|O(n!)|factorial time||
|O(infinity)|infinite time||

## Selection Sort
- Find the smallest unsorted element and add it to the end of a sorted list
- In pseudocode (repeat this until sorted):
	+ Search the unsorted part of the data to find the smallest value
	+ swap the smallest found value with the first element of the unsorted part
- Worst-case scenario: iterate over each of the n elements (to find the smallest unsorted element) and we must repeat this process *n* times, since only one element gets sorted on each pass
- Best-case scenario: exactly the same! There's no way to guarantee the array is sorted until we go through
the process for all of the elements
- Worst Case: O(n^2)
- Best Case: Omega (n^2)

## Bubble Sort
- In pseudocode:
	+ set swap counter to a non-zero value (i.e. -1; otherwise it won't run once)
	+ repeat until the swap counter is 0:
		* reset swap counter to 0;
		* look at each adjacent pair; if not in order, swap them and add one to the swap counter
- Worst-case scenario: array is in reverse order
- Best-case: array is already perfectly sorted and make no swaps on the first pass
- Worst Case: O(n^2)
- Best Case: Omega (n)

## Insertion Sort
- build your sorted array in place, shifting elements out of the way if necesary to make room as you go
- In pseudocode:
	+ call the first element of the array "sorted"
	+ Repeat until all elements are sorted:
		* Look at the next unsorted element. Insert into the sorted portion by shifting the requisite number
		of elements
- we didn't have to go back and forth across the array
- Worst case scenario: array is in reverse order; we have to shift *n*elements *n* positions each time we make an insertion
- Best case scenario: the array is already perfectly sorted and we simply keep moving the line between "unsorted" and "sorted" as we examine each element
- Worst Case: O(n^2)
- Best Case: Omega (n)

## Merge Sort
- Merge sort leverages recursion
- Break arrays into arrays of one element that are "sorted"
- Essentially: sort the left half, sort the right half, merge the two halves
- Worst-case scenario: split n elements up and then recombine them, effectively doubling the sorted
subarrays as we build them up
- Best case scenario: The array is already perfectly sorted but we will still have to split and recombine it back together
- Worst Case: O(n log n)
- Best Case: Omega (n log n)

## Linear Search
- itrate across the array from left to right, searching for a specified element
- In pseudocode:
	+ repeat, starting at first element:
		* is the first element is what you're looking for? Yes, stop;
		* If No, move to the next element
- Worst-case scenario: we look through entire array of n elements (it's the last item or it's not in the array)
- Best-case scenario: it's the first item
- Worst Case: O(n)
- Best Case: Omega (1)

## Binary Search
- This is divide and conquer => we can only do this if the array is **sorted**
- In pseudocode:
	+ Repeat until the (sub)array is of size 0:
		* calculate midpoint
		* if target, then stop
		* if target < midpoint, move start point to left of that and then divide in half again
- if element does not exist, end point will be lower than start point creating a subarray of 0
- Worst case scenario: we have to divide a list of n elements repeatedly in half either because that's where
the element is or it's not in the array
- Best case scenario: target element is at midpoint of full array
- Worst Case: O(log n)
- Best Case: Omega (1)

## Recursion
- A recursive funciton is one that, as part of its execution, calls itself
- `fact(n) = n * fact(n-1)`
- Every recursive function has two cases that could apply, given any input:
	+ the **base case**, which when triggered will terminate the recursive function
	+ the **recursive case**, which is where the function calls itself

```c
int fact(int n)
{
	if (n == 1) 
	{
		return 1;
	}
	else
	{
		return n * fact(n-1);
	}

}

```

- that can be slimmed down in C if a conditional only has a return line then:

```c
int fact(int n)
{
	if (n == 1) 
		return 1;
	else
		return n * fact(n-1);
}

```

- In general, but not always, recursive functions replace loops in non-recursive functions
- It's possible to have more than one base case
- The Collatz Conjecture applies to positive integers and speculates that it is always possible to get back to 1:
	+ if n is 1, stop
	+ Otherwise, if n is even, repeat this process on n/2
	+ Otherwise, if n is odd, repeat this process on 3n + 1

## Algorithms Summary

|Algorithm Name|Basic Concept|Big O|Omega|
|:---:|:---|:---:|:---:|
|Selection Sort|Find the smallest unsorted element in an array and swap it with first unsorted element in that array|n^2|n^2|
|Bubble Sort|Swap adjacent pairs of elements if they are out of order, effecting "bubbling" larger elements to the right and smaller ones to the left|n^2|n|
|Insertion Sort|Go through the array one time from left to right, shifting elements as necessary to insert each element into its correct place|n^2|n|
|Merge Sort Sort|Split the full array into subarrays, then merge those subarrays back together in the correct order|n log n|n log n|
|Linear Search|Iterate across the array from left-to-right, trying to find the target element|n|1|
|Binary Search|Given a sorted array, divide and conquer by systematically elminating half of the remaining elements in the search for the target|log n|1|

## GDB (the GNU Debugger)
- to kick things off with GDB:
	+ `gdb <program name>`
	+ that will pull up the GDB environment. The next two major commands you'll likely use (in order) are:
		* `b [function name, line number]` or `break [function name, line number]`
			- program will run uninterrupted until it encounters the function with that name or hits that line
			number, at which point it will pause and wait further instructions
		* `r [command-line arguments]`
			- runs program with the command line arguments provided, if any
- Other commands:

|command|actions|
|:---:|:---:|
|`n`|will step forward one block of code|
|`s`|will step forward one line of code|
|`p [variable]`|prints out the value of the variable given|
|`info locals`|prints out the values of all local variables|
|`bt`|show you what series of function calls led you to the current point in the program|
|`q`|quits GDB|


# Week 3

## Call Stacks
- when you call a function, the system sets aside space in memory for that function to do its necessary work. These
chunks of memory are called **stack frames** or **function frames**
- More than one function's stack frame may exist in memory at a given time. If `main()` calls `move()`, which then
calls `direction()`, all three have open frames but they don't all have active frames
- only the frame on the top of the stack is "active"
- Frames are arranged in a **stack**. The frame for the most recently called function is always on top
- When a new frame is called, it's pushed onto the top of the stack and becomes *active*
- When a function finishes its work, its frame is popped off the stack and the frame below it becomes the new, 
active function on top of the stack. This function immediately picks up where it left off

## File Pointers
- the ability to read data from and write data to files is the primary means of storing **persistent data**, 
data that does not disappear when your program stops running
- the abstraction of files that C provides is implemented in a data structure known as a FILE
	+ almost universally when working with files, we will be using pointers to them, `FILE*`
- The file manupulations functions all live in `stdio.h`
	+ all of them accept `FILE*` as one of their parameters, except for `fopen`
- `fopen()`
	+ opens a file and returns a file pointer to it
	+ always check the return value to make sure you don't get back NULL
	+ `FILE* ptr = fopen(<filename>, <operation>);`
	+ example: `FILE* ptr = fopen("file1.txt", "r");`
		* "r" = read
		* "w" = write (risks overwriting the file)
		* "a" = append (add to the file)
- `fclose()`
	+ closes the file pointed to by the given file pointer
	+ `fclose(ptr1)`
- `fgetc()`
	+ reads and returns the next character from the file pointed to
	+ Note: the operation of the file pointer passed in as a parameter must be "r" for read, or you'll
	get an error
	+ `char ch = fgetc(<file pointer>);`
- the ability to get single characters from files, if wrapped in a loop, means we could read all the 
characters from a file and print them to the screen, one-by-one:

```c
char ch;
while((ch = fgetc(ptr)) != EOF)	// EOF is a special word indicating end-of-file
	printf("%c", ch);
```
- `fputc()`
	+ writes or appends the specified character to the pointed-to file
	+ Note: the operation of the file pointer passed in as a parameter must be "w" for write or "a" for
	append or you'll get an error
	+ `fputc('A', ptr2);`

```c
char ch;
while((ch = fgetc(ptr)) != EOF)
	fputc(ch, ptr2);
```
  - this is essentially the `cp` command in Linux command line
- `fread()`
	+ reads <qty> units of size <size> from the file pointed to and stores them in memory in a buffer
	(usually an array) pointed to by <buffer>
	+ Note: the operation of the file pointer passed in as a parameter must be "r" for read or you'll
	get an error
	+ Examples:
	
```c
int arr[10]
fread(arr, sizeof(int), 10, ptr);

// We could also dynamically allocate a buffer using malloc.
// When dynamically allocating memory, we're saving it on the heap, not the stack
double* arr2 = malloc(sizeof(double) * 80);
fread(arr2, sizeof(double), 80, ptr);

/*
- We can also treat `fread` just like a call to `fgetc`.
- In this case, we're just trying to get one character from the file and we don't need an array to hold a character,
we can just store it in a character variable.
- The catch, though, is that when we just have a variable, we need to pass in the address of that variable
because recall that the first argument to fread is a pointer to the location and memory where we want to store the information.
- Hence the &c as opposed to just c
*/
char c;
fread(&c, sizeof(char), 1, ptr);
```

- `fwrite()`
	+ writes <qty> units of size <size> to the file pointed to by reading them from a buffer (usually an array)
	pointed to by <buffer>
	+ Note: the operation of the file pointer passed in as a parameter must be "w" for write or "a" for append
	or you'll get an error


## Pointers
- Pointers provide an alternative way to pass data between functions
	+ recall that we have (up to this point) passed all data by value, with one exception
	+ when we pass data vy value, we only pass a copy of that data
- If we use pointers instead, we have the power to pass the variable itself
	+ that means that a change that is made in one function **can** impact what happens in a different function
	+ previously, that wasn't possible!
- Pointers are related to memory
- Every file on your computers lives on your disk drive, either a hard disk drive (HDD) or a solid state drive (SSD)
disk drives are just storage space; we can't directly work there. Manipulation and use of data can only take place in
RAM, so we have to move data there
- Memory is basically a huge array of 8-bit wide bytes (512 MB, 1GB. 2GB. 4GB)

|Data Type|Size (in bytes)|
|:---:|:---:|
|int|4|
|char|1|
|float|4|
|double|8|
|long long|8|
|string|???|

- memory is just a big array of byte-sized cells
- every element of that array has an address
- arrays are useful for not just **storage** of information but also for *random access* (accessing
individual elements of the array by indicating which index location we want)
- every location in memory has an address
- string must end with `\0` so if there are 5 characters, we need a size of 6
- A pointer is nothing more than an address
- Pointers are addresses to memory where variables live
- a pointer is a data item whose:
	- **value** is a memory address
	- **type** describes the data located at that memory address
* pointers allow data structures and/or variables to be shared among functions
* pointers make a computer environment more like the real world
	- think of the notebook example of making changes
* the simplest pointer available to us in C is the NULL pointer
* When you create a pointer and you dont set its value immediately, you should **always** set the value
of the pointer to NULL
* You can check whether a pointer is NULL using the equality operator
* Another way is to simply extract the address of an already existing variable. We can do this
with the address extraction operator (&)
* if `x` is an int-type variable, then `&x` is a pointer-to-int whose value is the address of x
* if `arr` is an array of doubles, then `&arr[i]` is a pointer-to-double whose value is the address
of the ith element of `arr`
	- an array's name, then, is actually just a pointer to its first element
* arrays are just pointers
* The main purpose of a pointer is to allow us to modify or inspect the location to which it points
	- we do this by dereferencing the pointer
* if we have a pointer-to-char called `pc`, then `*pc` is the data that lives at the memory address stored
inside the variable `pc`
* Used in this context, `*` is known as the dereference operator
* It "goes to the reference" and accesses the data at that memory location, allowing you to manipulate
it at will
* This is just like visiting your neighbor. Having their address isn't enough. You need to **go to** the address
and only then can you interact with them
- What happens if we try to dereference a pointer whose value is NULL
	+ **Segmentation fault**
	+ this is good behavior! It defends against accidental dangerous manipulation of unknown pointers
	+ that's why we recommend you set your pointers to NULL immediately if you aren't setting them to a known, 
	desired value
- `int* p;`
	+ the value of `p` is an address (*because all pointers are addresses*)
	+ we can dereference `p` with the `*` operator
	+ if we do, what we'll find at that location is an int
- Another annoying thing with those *'s. They're an important of both the name and the variable name
	+ `int* px, py, pz` => doesn't work
	+ `int* pa, *pb, *pc` => creates three pointers on one line
- string doesn't exist; it's actually a `char*`

|Data Type|Size (in bytes)|
|:---:|:---:|
|int|4|
|char|1|
|float|4|
|double|8|
|long long|8|
|string|???|
|char*|4 or 8|

- `*pk = 35;`
	+ we go to the address of that pointer and change the value there to be 35

```c
int m;
m = 4;
pk = &m;
```
- building from the example before it, what we are doing here is simply changing pk to point at m and not 35

## Dynamic Memory Allocation
- we can use pointers to get access to a block of dynamically-allocated memory at runtime
- dynamically allocated memory comes from a pool of memory known as the **heap**
- prior to this point, all memory we've been working with has been coming from a pool of memory known as the stack
- the heap and stack are part of the same pool of memory they just come from different parts; heap goes down, stack goes up (in the common illustration of heap and stack)
- We get this dynamically-allocated memory by making a call to the C standard library function `malloc()`, passing as its parameter the number of bytes requested
- After obtaining memory for it, `malloc()` will return a pointer to that memory
- What if `malloc()` can't give you memory? It'll hand you back NULL
	+ when using `malloc()`, you must check that it is not NULL
	+ dereferencing a NULL pointer leads to a segmentation fault

```c
// statically obtain an integer
int x;

// dynamically obtain an integer
int *pk = malloc(sizeof(int));

// get an integer from the user
int x = getInt();

// array of floats on the stack
float stack_array[x];

// array of floats on the heap
float* heap_array = malloc(X * sizeof(float));
```

- Here's the trouble: Dynamically-allocated memory is not automatically returned to the system for later use when
the function in which it's created finishes execution
- Failing to return memory back to the system when you're finished with it results in a memory leak which can
compromise your system's performance
- When you finish working with dynamically-allocated memory, you must `free()` it

```c
char* word = malloc(50 * sizeof(char));

// do stuff with word

// now we're done working with that block
free(word);
```

- Three golden rules:
	+ every block of memory that you `malloc()` must be subsequently be `free()`d
	+ Only memory that you `malloc()` should be `free()`d
	+ Do not `free()` a block of memory you have already freed

```c
// we create an integer variable called m; it stores integers
int m;

// similar; it's capable of holding an int but is not itself an integer
int* a;

// this actually creates two boxes but also establishes a pointer relationship
// b is a pointer and lives on the stack; b contains the address
int* b = malloc(sizeof(int));

// a points to m (a is getting m's address)
a = &m;

// a NOW points to the same place that b points to; a now points to where b points
a = b;

// puts a 10 in the box for variable m
m = 10;

// dereference b and put some value in that memory location; in this case, it is 10 + 2 = 12;
// so now, b is pointing to 12
*b = m + 2;

// we give up the memory that we malloc()d for b; we have essentially gotten rid of 12
free(b);

// we'd get a segmentation fault
// a WAS pointing to b but we freed b...so now that value is gone and we'd get a segmentation fault
*a = 11;
```

## Hexadecimal
- most Western cultures use the decimal system, aka *base-10* to represent numeric data
- computers use the binary system, *base-2*, to represent numeric data
- as computer scientists, it's useful to be able to epxress data the same way the computer does
- the problem, of course, is that trying to parse a huge chain of of 0s and 1s can be quite difficult
- the hexadecimal system, *base-16*, is a much more concise way to express the data on a computer's system
	+ 0 1 2 3 4 5 6 7 8 9 a b c d e f
- hexadecimal makes this mapping easy because a group of four binary digits (bits) has 16 different combinations, and each of those combinations maps to a single hexadecimal digit
- we usually preface hexadecimal with `0x` to indicate that we are looking at hexadecimal

|Decimal|Binary|Hexadecimal|
|:---:|:---:|:---:|
|0|0000|0x0|
|1|0001|0x1|
|2|0010|0x2|
|3|0011|0x3|
|4|0100|0x4|
|5|0101|0x5|
|6|0110|0x6|
|7|0111|0x7|
|8|1000|0x8|
|9|1001|0x9|
|10|1010|0xA|
|11|1011|0xB|
|12|1100|0xC|
|13|1101|0xD|
|14|1110|0xE|
|15|1111|0xF|

- binary has place values (1,2,4,8,...)
- as does decimal (1,10,100,1000)
- to convert binary to hexadecimal, group four binary digits (bits) together from right to left
	+ pad the leftmost group with extra 0 bits at the fron if necessary
- 01000110101000101011100100111101
- 0100 0110 1010 0010 1011 1001 0011 1101
-   4    6   A    2    B    9    3    D
-   0x46A2B93D


## HOMEWORK: Whodunit
- take BMP clue
- Items To Do:
	+ open file
	+ update header's info for outfile
	+ read clue's scanline, pixel by pixel
	+ change pixel's color as necessary
	+ write verdict's scanline, pixel by pixel
- `copy.c`
	+ already does a lot of things: opens a file, updates header, reads each scanline, writes each pixel in the output file
- Items to do:
	+ `cp copy.c whodunit.c`
- BITMAPINFOHEADER
	+ biWidth (bitmap info Width)
	+ biHeight
	+ biSizeImage
- BITMAPFILEHEADER
	+ bfSize
		* total size of file (in bytes)
	+ bf.bfSize = bi.biSizeImage + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)
- fread(data, size, number, inptr)
	+ data - pointer to a struct that will contain the bytes you're reading
	+ size - size of each element to read
	+ number - number of elements to read
	+ inptr - FILE * (pointer) to read from
- pixel color - represented by 3 bytes
- RGBTRIPLE scruct
	+ a struct to represent pixels
	+ here is a green pixel:

```c
RGBTRIPLE triple;
triple.rgbtBlue = 0x00;
triple.rgbtGreen = 0xff;
triple.rgbtRed = 0x00;
```

- One way to decode it would be to turn all pure red into white
- writing files
	+ `fwrite(data, size, number, outptr)`
- padding
	+ each pixel is 3 bytes
	+ length of each scanline must be 4 bytes
	+ if the number of pixels isn't 4, we must add some padding (0x00)
	+ each scanline must be a multiple of 4:
		* Ex #1: scanline has 4 RGBtriple's => no padding needed (4 * 3 = 12; 12 is a multiple of 4)
		* Ex #2: scanline has 5 RGBtriple's => 1 byte of padding required (5 * 3 = 15; plus 1 is 16)
			- one byte of padding is 0x00
		* Ex #3: scanline has 6 RGBtriple's => 2 bytes of padding required (6 * 3 = 18; plus 2 is 20)
	+ We don't have to come up with the formula, the padding formula is given
- write padding
	+ `fputc(chr, outptr)`
		* chr => char to write
		* outptr => FILE * to write to
- file position indicator
	+ `fseek(inptr, offset, from);`

## Resize

- bitmaps are just an arrangement of bytes, it's all about how we read them
- Because we are changing the size of the file we have to change the header file
- BITMAPINFOHEADER
	+ biWidth (width of image in pixels)
	+ biHeight (height of image in pixels)
	+ biSizeImage (total size of image in bytes) => includes pixels and padding
- What's changing when scaling by n?
	+ bi.biWidth => bi.biWidth * n
	+ bi.biHeight => bi.biHeight * n
	+ bi.biSizeImage => ((biWidth * n) * sizeof(RGBTRIPLE) + padding) * abs(biHeight * n)
	+ bf.bfSize => sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + biSizeImage
- Resize horizontally
	+ write each pixel twice!
- padding
	+ to write padding, we need `fputc()`
- fseek() needed
- pseudocode:
	+ for each row:
		* for each pixel
			- write to array n times
		* for n times
			- write array to outfile
			- write outfile padding
		* skip over infile padding

## Recover

- TODO
	+ open memory card file
		* fopen
		* check if its null
		* we start at the beginning and check the first few bytes to see if it is a JPEG. If not, we can then
		skip to the next block of 512 bytes
		* CM => right away, I am unsure about how to read the bytes or the proper struct I should be using. The
		looping through the bytes seems easy; it's the comparison of those bytes is what seems hard
	+ find beginning of JPEG
		* once we find a JPEG, we just write 512 bytes at a time until we reach the end of the JPEG
	+ open a new JPEG write 512 bytes until new JPEG is found
	+ 
	+ detect end of file

- JPEGs
	+ each JPEG starts with a distinct header
		* first three bytes: 0xff 0xd8 0xff
		* last byte: 0xe0 0xe1 0xe2 ... 0xef
	+ stored side-by-side on the memory card
	+ each block is 512 bytes
	+ One recommendation is the bitwise and operator:
		* `if (buffer[0] == 0xff && buffer[1] == 0xd8 && buffer[2] == 0xff && (buffer[3] & 0xf0) == 0xe0)`
		* filenames need to be formated as follows: ###.jpg
		* named in the order in which they are found, starting at 000
	+ making a new JPEG
		* `sprintf(filename, "%03i.jpg", 2);`
			- filename: char array to store the resultant string
			- looks like this returns something with 3 places whatever the ith int is where 2 is the
			number we want in there ====> 002.jpg
		- FILE *img = fopen(filename, "w");
- Reading files
	+ fread(data, size, number, inptr)
	+ data: pointer to a **struct** that will contain the bytes you're reading
	+ size: size of each element to read
		* sizeof
	+ number: number of elements to read
	+ inptr: FILE * to read from
	+ fread returns the number of elements successfully read
		* `fread(buffer, 1, 512, raw_file)` OR
		* `fread(buffer, 512, 1, raw_file)`
- Writing files
	+ `fwrite(data, size, number, outptr);`
	+ data - pointer to the struct that contains the bytes you're reading from
	+ size
	+ number
	+ outptr: FILE * to write to
- End of file?
	+ fread returns the number of elements successfully read
		* `fread(buffer, 1, 512, raw_file)` OR
		* `fread(buffer, 512, 1, raw_file)`
	+ `fread(data, size, number, inptr);`
		* return how many items of size `size` were read (and ideally, it returns a number)
		* use directly in a condition!
- pseudocode
	+ open card file
	+ repeat until end of card
		* read 512 bytes into a buffer
		* start of a new JPEG?
			- yes ->
			- no ->
		* already found a JPEG?
			- no ->
			- yes ->
	+ close any remaining files

[back to top](#top)

# Week 4
- lecture 5

## Structures
- structures provide a way to unify several variables of different dyptes into a single, new variable
type which can be assigned to its own type name
- we structures (structs) to group together elements of a variety of data types that have a logical
connection

```c
// Defining a Struct
struct car
{
	int year;
	char model[10];
	char plate[7];
	int odometer;
	double engine_size;
}

```
  - `struct` => indicates that we are creating a new struct
  - `car` => name of the struct
  - inside the curly braces are the fields of my struct
  - each field (or member) of the struct must end with a semicolon
  	+ *similar to the **property** of a JS object*
- Once we have a defined structure, which we typically do in separate .h files or atop our programs outside
of any funcitons
- that means we create variables of that type using the familiar syntax
- we access those fields (also known as members) using the dot operator (.)

```c
// variable declaration
struct car mycar;

// field accessing
mycar.year = 2011;
mycar.plate = "CS50";
mycar.odometer = 50505;
```

- Structures, like variables of all other data types, do not need to be created on the stack. We can 
dynamically allocate structure at run time if our program requires it
- In order to access the fields of our structures in that situation, we first need to dereference the
pointer to the structure, and then we can access its fields

```c
// variable declaration
struct car *mycar = malloc(sizeof(struct car));

// field accessing
(*mycar).year = 2011;
(*mycar).plate = "CS50";
(*mycar).odometer = 50505;
```
- Instead of declaring mycar on the stack `struct car mycar`, I can do the above. That returns a pointer to the
block of memory. As a refresher, **malloc** allocates the requested memory of a particular size and returns a
pointer to it.
- To access the fields, I first dereference my car using the dereference operator, `*mycar`, and then after I
dereference, I use the dot operator to access the various fields of mycar.
- THe arrow operator allows us to trim that down

```c
// variable declaration
struct car *mycar = malloc(sizeof(struct car));

// field accessing
mycar->year = 2011;
mycar->plate = "CS50";
mycar->odometer = 50505;
```
- what is happening is that first, we are dereferencing `mycar` (which is a pointer here), we then access the fields.
- **So what is dereferencing?**
	+ "Dereferencing a pointer means getting the value that is stored in the memory location pointed by the pointer"

## Defining Custom Types
- the C keyword `typedef` provides a way to create a shorthand or rewritten name for data types
- the basic idea is to first define a type in the normal way, then alias it to something else
- `typedef <old name> <new name>`
- `typedef unsigned char byte`
	+ we can now just use "byte" instead of unsigned char
- `typedef char* string`

```c
struct car
{
	int year;
	char model[10];
	char plate[7];
	int odometer;
	double engine_size;
};

typedef struct car car_t;

// that can be rewritten more concisely by essentially wrapping the struct code between "typedef"
// and the our alias. See below:

typedef struct car
{
	int year;
	char model[10];
	char plate[7];
	int odometer;
	double engine_size;
}
car_t;
```

- here is an example of what we had to do before and what we can do now:

```c
// OLD WAY
// variable declaration
struct car mycar;

// field accessing
mycar.year = 2011;
mycar.plate = "CS50";
mycar.odometer = 50505;

// NEW WAY
// variable declaration
car_t mycar;

// field accessing
mycar.year = 2011;
mycar.plate = "CS50";
mycar.odometer = 50505;
```

## Singly-Linked Lists
- So far in the course, we've only had one kind of data structure for representing collections of
like values
	+ structs, recall, give us "containers" for holding variables of different data types, typically
- Arrays are great for element lookup, but unless we want to insert at the very end of the array, 
inserting elements is quite costly
- arrays also suffer from a great inflexibility - what happens if we need a larger array than we thought?
- through clever use of pointers, dynamic memory allocation and structs, ew can put the pieces together to develop a new kind of data structure that gives us the ability grow and shrink a collection of like values to fit our needs
- Signly-Linked Lists
	+ we call this combination of elements, when used in this way, a linked list
	+ a linked list **node** is a psecial kind of struct with two members:
		* data of some data type (int, char, float)
		* a pointer to another node of the same type
	+ in this way, a set of nodes together can be though of as forming a chain of elements that we can follow from beginning to end

```c
typedef struct sllist
{
	// VALUE just represents any data type (int, char, etc); VALUE is an arbitrary data type
	VALUE val;
	struct sllist* next;
}
sllnode;
```
- this is a self-referential structure
- at the end of the day, we want to call it `sllnode`
- but we can't reference it because we haven't created it yet
- So `struct sllist` is the temporary name that we use so that we can point to it in the struct
and then provide the real name `sllnode` at the bottom
- In order to work with linked lists effectively, there are a number of operations that we need to understand:
	+ Create a linked list when it doesn't exist
	+ search through a linked list to find an element
	+ insert a new node into the linked list
	+ delete a single element from a linked list
	+ delete an entire linked list
- Create a linked list
	+ `sllnode* create(VALUE val);`
	+ this function should return a pointer to that list
	+ Pseudocode:
		* dynamically allocate space for a new `sllnode`
		* check to make sure we didn't run out of memory
		* initialize the node's `val` field
		* initialize the node's `next` field
		* return a pointer to the newly created `sllnode`
	- `sllnode* new = create(6);`
- Search through a linked list to find an element
	+ `bool find(sllnode* head, VALUE val);`
	+ pseudocode:
		* create a traversal pointer pointing to the list's head
		* if the current node's val field is what we're looking for, report success
		* if not, set the traversal pointer to the next pointer in the list and go back to step b
		* if you've reached the end of the list, report failure
	+ `bool exists = find(list, 6);`
	+ with linked lists, we no longer really have random access; we can't go to the 3rd element in the list, 
	we have to traverse the tree
- Insert a new node into the linked list
	+ `sllnode* insert(sllnode* head, VALUE val);`
	+ Steps involved:
		* Dynamically allocate space for a new sllnode
		* Check to make sure we didn't run out of money
		* Populate and insert the node at the beginning of the linked list
			- why? Because you can do it immediately. you don't have to traverse the entire list just
			to add a new node
		* Return a pointer to the new head of the linked list
	+ `list = insert(list, 12);`
+ Delete an entire linked list
	* `void destroy(sllnode* head);`
	* pseudocode:
		- if you've reach a null pointer, stop
		- Delete the rest of the list
		- free the current node
	* If we just freed the first element, we wouldn't be able to find the other nodes and free them. Those other elements would still be taking up memory and would represent a memory leak
+ Delete a single element from a linked list
	* we will talk about this in doubly-linked lists


## Hash Tables
- Hash tables combine the random access ability of an array with dynamism of a linked list
- This means (assuming we define our hash table well):
	+ insert can start to tend toward (theta)(1)
	+ deletion can start to tend toward (theta)(1)
	+ lookup can start to tend toward (theta)(1)
- We're gaining the advantages of both types of data structure while mitigating the disadvantages
- To get this performance upgrade, we createa  new structure whereby when we insert data into the structure, the data itself gives us a clues about where we will find the data, should we need to look it up
- The trade is off is that hash tables are not great at ordering or sorting data
- Only use hash tables if we don't care if data is sorted
- A hash table amount to a combination of two things with which we're quite familiar:
	+ a **hash function**, which returns a nonnegative integer value called a *hash code*
	+ an **array** capable of storing data of the type we wish to place into the data structure
- The idea is that we run our data through the hash function and then store the data in the element of the array represented by the hash code
- How to define a hash function? Really no limit to the number of possible hash functions
- A good hash function should:
	+ use only the data being hashed
	+ use all of the data being hashed
	+ Be deterministic
	+ uniformly distribute data
	+ Generate very different hash code for very similar data

```c
unsigned int hash(char* str)
{
	int sum = 0;
	for(int j = 0; str[j] != '\0'; j++)
	{
		sum += str[j];
	}
	return sum % HASH_MAX;
}
```

- You should **not** be writing your own hash functions. There are plenty of hash functions on the internet that do what you want
- A **collision** occurs when two pieces of data, when run through the hash function, yield the same hash code
- presumably we want to store *both* pieces of data in the hash table, so we shouldn't simply overwrite the data that happened to be placed in there first
- We need to find a way to get both elements into the hash table while trying to preserve quick insertion and lookup
- Resolving collisions: *linear probing*
- In this method, if we have a collision, we try to place the data in the next consecutive element in the array (wrapping around to the beginning if necessary) until we find a vacancy
- that way, if we don't find what we're looking for in the first location, at least hopefully the element is somewhere nearby
- Linear probing is subject to a problem called **clustering**. Once there's a miss, two adjacent cells will contain data making it more likely in the future that the cluster will grow
- Even if we switch to another probing technique, we're still imited. We can only store as much as we have locations in our array
- Resolving collisions: **Chaining**
- What if instead of each element of the array holding just one of piece of data, it held multiple pieces of data
- If each element of the array is a pointer to the head of a linked list, then multiple pieces of data can yield the same hash code and we'll be able to store it all
- With chaining, we've eliminated clustering
- We know that linked lists that insertion (and creation, if necessary) into a linked list is an O(1) operation
- For lookup, we only need to serach through what is hopefully a small list since we're distributing what would otherwise be one huge list across *n* lists

## Tries
- Arrays: the key is the element index, the value is the data at that location
- Hash table: the key is the has code of the data, the value is a linked list of data hashing to that hash code
- What about a slightly different kind of data structure where the key is guaranteed to be unique?
- Tries combine structures and pointers together to store data in an interesting way
- the data to be searched for in the trie is now a roadmap
	+ if you can follow the map from beginning to end, the data exists in the trie
	+ if you can't, it doesn't
- Unlike a hash table, there are no collisions, and no two pieces of data (unless they're identical) have the same path
- Let's map key-value pairs where the keys are four-digit years (YYYY) the values are names of universities founded during those years
- in a trie, the paths from a central **root** node to a **leaf** node (where the school names would be) would be labeled with digits of the year
- each node on the path from root to leaf could have 10 pointers emanating from it, one for each digit

```c
typedef struct _trie
{
	char university[20];
	struct _trie* paths[10];
}
trie;
```

## Stacks
- Stack is also a name for a section of memory a statically declared memory but there is also a stack data structure
- A stack is a special type of structure that can be used to maintain data in an organized way
- this data structure is commonly implemented in one of two ways: as an **array** or as a **linked list**
- in either case, the important rule is that when data is added to the stack, it sites "on top" and so if an element needs to be removed, the most recently added element is the only element that can legally by removed
	+ **LIFO** => Last in, First Out
- There are only two operations that may legally be performed:
	+ **Push**: add a new element to the top of the stack
	+ **Pop**: remove the most recently added element

```c
typedef struct _stack
{
	// VALUE = int, char, whatever
	// CAPACITY = some constant size => notice, it can't be dynamically resized
	// top => we must keep track of the top-most element
	VALUE array[CAPACITY];
	int top;
}
stack;

// declare a stack:
stack s;

// set top
s.top = 0;
```
- In the general case, `push()` needs to:
	+ accept a pointer to the stack
	+ accept data of type VALUE to be added to the stack
	+ add that data to the stack at the top of the stack
	+ change the location of the top of the stack
- `void push(stack* s, VALUE data)`
	+ this is what the function declaration could look like

```c
stack s;
s.top = 0;
push(&s, 28);

push(&s, 33);

push(&s, 19);
```
- In the general case, `pop()` needs to:
	+ accept a pointer to the stack
	+ change the location of the top of the stack
	+ return the value that was removed from the stack
- `VALUE pop(stack* s);`

```c
int x = pop(&s);
// now x is 19; top is now 2;

int x = pop(&s);
// now x is 33; top is now 1

push(&s, 40);
// top is now 2 again
```

- Linked lists are another way to implement stacks:

```c
typedef struct _stack
{
	VALUE val;
	struct _stack *next;
}
stack;

// NOTICE HOW IT COMPARES TO OUR PREVIOUS DEFINITION OF A LINKED LIST
typedef struct sllist
{
	VALUE val;
	struct sllist* next;
}
sllnode;
```

- just to make sure to always maintain a pointer to the head of the linked list
- to push, dynamically allocate a new node, set its next pointer to point to the current head of the list, then move the head pointer to the newly-created node
- to pop, traverse the linked list to its second element, free the head of the list, then move the head pointer to the (former) second element

## Queues
- A queue is a special type of structure that can be used to maintain data in an organized way
- this data structure is commonly implemented in one of two ways: as an array or as a linked list
- in either case, the important rule is that when data is added to the queue, it is tacked onto the end, and
so if an element needs to be removed, the element at the fron is the only element that can be legally removed
  - FIFO = first in, first out
- there are only two operations that may legally by performed on a queue
	+ enqueue: add a new element to the end of the queue
	+ dequeue: remove oldest element from the fron to of the queue
- array based implementation:

```c
typedef struct _queue
{
	VALUE array[CAPACITY];
	int front;
	int size;
}
queue;

// instantiate a queue
queue q;
```
  - notice, we have no way to dynamically add more elements; we have to know the size of the queue (or at least its maximum size)
- Enqueue; in general, `enqueue()` needs to:
	+ accept a pointer to the queue
	+ accept data of type VALUE to be added to the queue
	+ add that data to the queue at the end of the queue
	+ change the size of the queue
- `void enqueue(queue* q, VALUE data);`
- `enqueue(&q, 28);`
- Dequeue; in general, `dequeue()` needs to:
	+ accept a pointer to the queue
	+ change the location of the front of the queue
	+ decrease the size of the queue
	+ return the value that was removed from the queue

```c
// value is what you'll be returning. enqueue was VOID because we weren't returning anything
VALUE dequeu(queue* q);

// the first element we added was 28 so 28 is what is returned
// so now, our front is set to index 1 and size is set to 2
int x = dequeue(&q);

// 33 is returned (the second element added)
// front = 2; size is 1
int x = dequeue(&q);

// front = 2 and size is 2
enqueue(&q, 40);
```

- linked-list implementation:

```c
typedef struct _queue
{
	VALUE val;
	struct _queue *prev;
	struct _queue *next;
}
queue;
```
- just to make sure to always maintain pointers to the head **and** tail of the linked list (probably global)
- To **enqueue**:
	+ dynamically allocate a new node
	+ set its next pointer to NULL, set its prev pointer to the tail;
	+ set the tail's next pointer to the new node
	+ move the tail pointer to the newly-created node
- `enqueue(tail, 10);`
- to **dequeue**:
	+ traverse the linked list to its second element (if it exists)
	+ free the head of the list
	+ Move the head pointer to the (former) second element
	+ Make that node's prev pointer point to NULL 

## Data Structures
- We've examined four different ways to store data:
	+ arrays
	+ linked lists
	+ hash tables
	+ tries
- there are some variations on these: trees and heaps (similar to tries), stacks and queues are quite similar to arrays or linked lists
- Arrays
	+ insertion is bad - lots of shiting to fit an element in the middle
	+ deleteion is bad - lots of shifting after removing an element
	+ lookup is great - random access, constant time
	+ relatively easy to sort
	+ relatively small size-wise
	+ stuck with a fixed size, no flexibility
- Linked Lists
	+ insertion is easy - just tack onto the front
	+ deletion is easy - once you find the element, you just change the pointers
	+ lookup is bad - have to rely on linear search
	+ relatively difficult to sort - unless you're willing to compromise on super-fast inertion and instead sort as you construct
	+ relatively small size-wise (not as small as arrays)
- Hash Tables
	+ Insertion is a two-step process - hash, then add
	+ deletion is easy - once you find the element
	+ lookup is on average better than with linked lists because you have the benefit of a real-world constant factor
	+ not an ideal data structure if sorting is the goal - just use an array
	+ can run the gamut of size
- Trie
	+ insertion is complex - a lot of dynamic memory allocation, but gets easier as you go
	+ deletion is easy - just free a node
	+ lookup is fast - not quite as fast as an array but almost
	+ already sorted - sorts as you build in almost all situations
	+ rapidly become huge, even with very little data present, not great if space is at a premium



## Speller
- speller.c
	+ calls `load` on the dictionary file
		* dictionary contains valid words, one per line
	+ calls `check` on each word in the text file and prints all misspelled words
	+ calls `size` to determine the number of words in dictionary
	+ calls `unload` to free up memory
- our job is to implement those four functions: load, check, size, unload
- `check`
	+ case-insensitivity
	+ assume strings with only alphabetical characters and/or apostrophes
	+ if the word exists, it can be found in the hash table
	+ which bucket would the word be in?
		* `hashtable[hash(word)]`
	+ search in that linked list
		* `strcasecmp`

### Load

+ for each word in the dictionary text file, store it in the dictionary's data structure
	* linked lists
	* hash tables
	* tries
+ hash tables
	* an array of buckets
	* each bucket is a linked list
	* hash function => returns the bucket that a given key belongs to
+ a hash table is simply an array of linked lists
+ linked lists contain nodes
+ nodes => each node has a value as well as a pointer to the next node
+ when dealing with linked lists, you cannot lose track of your pointers

```c
// Linked list
typedef struct node
{
	char word[LENGTH + 1];
	struct node *next;
}
node;

node *node1 = malloc(sizeof(node));
node *node2 = malloc(sizeof(node));

strcpy(node1->word, "Hello");
strcpy(node2->word, "World");
node1->next = node2;
```
  - the code above creates a linked list of size 2

```c
typedef struct node
{
	char word[LENGTH + 1];
	struct node *next;
}
node;

node *hashtable[50];
```
- make a new word
	+ scan dictionary word by word
	+ malloc a node * for each new word
	+ if pointer != NULL, copy word into node

```c
while (fscanf(file, "%s", word) != EOF)
{
	node *new_node = malloc(sizeof(node));
	if(new_node == NULL)
	{
		unload();
		return false;
	}
	strcpy(new_node->word, word);

}
```
- hash function
	+ takes a string
	+ returns an index
		* index < the number of buckets
	+ deterministic
		* the same value needs to map to the same bucket every time
	+ `new_node->word` has the word from the dictionary
	+ hashing `new_node->word` will give us the index of a bucket in the hash table
	+ insert into the linked list

- tries
	+ every node contains an array of node pointers
		* one for every letter in the alphabet + '\''
		* each element in the array points to another node
			- if that node is NULL, then that letter isn't the next letter of any word in that sequence
	* every node indicates whether it's the last character of a word

```c
typedef struct node
{
	bool is_word;
	struct node *children[27];
}
node;

node *root;
```

- for every dictionary word, iterate through the trie
- each element in `children` corresponds to a different letter
- check the value at `children[i]`
	+ if NULL, malloc a new node, have `children[i]` point to it
	+ if not NULL, move to new node and continue
+ if at end of word, set `is_word` to true

### Check
- case insensitive
- assume strings with only alphabetical characters and/or apostrophes
- if the word exists, it can be found in the hash table
- which bucket would the word be in?
	+ `hashtable[hash(word)]`
- search in that linked list
	+ `strcasecmp`
- traversing linked lists:

```c
node *cursor = head;
while(cursor != NULL)
{
	// do something
	cursor = cursor->next;
}
```

- traversing a trie
	+ for each letter in input word
		* go to corresponding element in children
			- if NULL, word is mispelled
			- if not NULL, move to next letter
		* once at end of input word
			- check if `is_word` is true

### Unload
- freeling linked lists:

```c
node *cursor = head;
while (cursor != NULL)
{
	node *temp = cursor;
	cursor = cursor->next;
	free(temp);
}
```

- unload a trie
	+ unload from bottom to top
	+ travel to lowest possible node
		* free all pointers in children
		* backtrack upwards, freeing all elements in each children array until you hit root node
	+ recursion!

- tips
	+ pass in a smaller dictionary
		* `./speller [dictionary] text`
		* default: loarge
		* also try: small
		* make your own!
	+ use pen and paper

### Notes



[back to top](#top)

# Week 5


### Lecture 6

- web server is just a piece of software whose purpose to serve web pages
- server-client relationship
- the client is our browser
- so many websites are prefixed with 'www' is to identify as part of the World Wide Web
- **http** => this is the protocol
- HTTP is a protocol is a set of conventions for how computers talk to each other
	+ like a handshake between two people
- `curl http://harvard.edu`
- `curl -I http://harvard.edu` => show only headers
- use the Network tab in Developer Tools to see the order of the files that you are getting back when you open a file
- Dynamic Host Configuration Protocol (DHCP)
- Domain Name System (DNS)
	+ translates domain names into IP addresses
- a server really is just a program despite how we think about them as being physical things
- TCP = Transmission Control Protocol
- TCP ports:
	+ 22 SSH
	+ 53 DNS
	+ 80 HTTP
	+ 443 HTTPS
	+ 587 SMTP
- when a server sends data, it sends it in packets
- TCP has data sent in packets and so if a packet is dropped, another one is sent
- `http-server -p 8080`
	+ sets up web server in CS50 IDE

### Internet Primer
- IP Address
	+ in order for your machine to uniquely identify itself on the Internet, it needs an address
		* so you can send and receive information
	+ **the addressing scheme used by competuers is known as IP addressing**
	+ as originally developed, IP addressing would allocate a unique 32-bit address to each device trying to connect to the internet
	+ instead of these representing addresses as hexadecimals, they used the normal decimals (8 bits)
	+ w.x.y.z where each one is in the range [0, 255]
	+ if each address is 32 bits, there are roughly 4 billion addresses to give out
		* so there is a problem: we don't have enough IP addresses
	+ we've been slowly phasing out IPv4 to IPv6
		* 128-bit addresses
	+ s:t:u:v:w:x:w:y:z
		* 8 separated chunks
		* each of these is represented by 1 to 4 hexadecimal digits in the range [0,ffff]
		* 1234:5678:90ab:cdef:fedc:ba09:8765:4321
		* 2001:4860:4860:0:0:0:0:8844 (Google) can also be represented as 2001:4860:4860::8844
- DHCP
	+ somewhere between your computer and the Internet at large exists a Dynamic Host Configuration Protocol (DHCP) server, whose role is to assign IP addresses
	+ pre-DHCP, the task of assigning IP addresses fell to a system administrator who would need to manually assign IP addresses
- DNS
	+ the Domain Name System exists to help us translate IP addresses to more memorable names that are human-comprehensible
	+ DNS is somewhat like the yellow pages of the web
	+ there is really no DNS record of the entire internet
	+ large DNS servers are more like aggregators, collecting smaller sets of DNS information and pooling them together, updating frequently
- Access Points
	+ generally, it could be the home or work network that you connect
	+ one of the ways we've dealth with the IPv4 addressing problem is to start assigning multiple people to the same IP address
	+ the IP address is assigned to a router, whose job it is to act as a traffic cop that allows data requests from all of the devices on a local network (your home, business, etc.) processed through a single IP
	+ Modern home networks combine a router, modem, a switch and other technologies into a single device
	+ Modern business networks or large-scale wide-area networks (WANs) still frequently have these as separate devices to allow the size of their network to scale more easily
- the internet is really just a set of protocols: it's a set of rules that allows all of these networks to talk to each other

### IP

### TCP

### HTTP

### HTML

### CSS

[back to top](#top)

# Week 6
- lectures 7 & 8

[back to top](#top)

# Week 7

[back to top](#top)

# Week 8

[back to top](#top)

# Week 9

[back to top](#top)

# Week 10

[back to top](#top)

# Week 11

[back to top](#top)