<a name='top'></a>
# CS50 - Intro to Computer Science

**Lectures**

- [Week 0](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-0)
- [Week 1](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-1)
- [Week 2](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-2)
- [Week 3](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-3)
- [Week 4](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-4)
- [Week 5](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-5)
- [Week 6](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-6)
- [Week 7](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-7)
- [Week 8](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-8)
- [Week 9](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-9)
- [Week 10](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-10)
- [Week 11](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/CS50-Notes.md#week-11)

**Lecture Notes**

|Lecture|Link|
|:---:|:---|
|0|[https://docs.cs50.net/2017/fall/notes/0/lecture0.html](https://docs.cs50.net/2017/fall/notes/0/lecture0.html)|
|1<br>(Week 1)|[https://docs.cs50.net/2017/fall/notes/1/lecture1.html](https://docs.cs50.net/2017/fall/notes/1/lecture1.html)|
|2<br>(Week 1 cont.)|[https://docs.cs50.net/2017/fall/notes/2/lecture2.html](https://docs.cs50.net/2017/fall/notes/2/lecture2.html)|
|3|[https://docs.cs50.net/2017/fall/notes/3/lecture3.html](https://docs.cs50.net/2017/fall/notes/3/lecture3.html)|
|4<br>(Week 3)|[https://docs.cs50.net/2017/fall/notes/4/lecture4.html](https://docs.cs50.net/2017/fall/notes/4/lecture4.html)|
|5<br>(Week 4)|[https://docs.cs50.net/2017/fall/notes/5/lecture5.html](https://docs.cs50.net/2017/fall/notes/5/lecture5.html)|
|6<br>(Week 5)|[https://docs.cs50.net/2017/fall/notes/6/lecture6.html](https://docs.cs50.net/2017/fall/notes/6/lecture6.html)|
|7<br>(Week 6)|[https://docs.cs50.net/2017/fall/notes/7/lecture7.html](https://docs.cs50.net/2017/fall/notes/7/lecture7.html)|
|8<br>(Week 6 cont.)|[https://docs.cs50.net/2017/fall/notes/8/lecture8.html](https://docs.cs50.net/2017/fall/notes/8/lecture8.html)|
|9<br>(Week 7)|[https://docs.cs50.net/2017/fall/notes/9/lecture9.html](https://docs.cs50.net/2017/fall/notes/9/lecture9.html)|
|10<br>(Week 8)|[https://docs.cs50.net/2017/fall/notes/10/lecture10.html](https://docs.cs50.net/2017/fall/notes/10/lecture10.html)|
|11<br>(Week 9)|[https://docs.cs50.net/2017/fall/notes/11/lecture11.html](https://docs.cs50.net/2017/fall/notes/11/lecture11.html)|
|12<br>(Week 11)|[https://docs.cs50.net/2017/fall/notes/12/lecture12.html](https://docs.cs50.net/2017/fall/notes/12/lecture12.html)|

# Homework

|Week|Homework|Submitted|See the code|
|:---:|:---|:---:|:---|
|0|*none*|*n/a*||
|1|Mario|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset1/mario_less.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset1/mario_less.c)|
| |Cash|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset1/cash.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset1/cash.c)|
| |Caesar|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset2/caesar.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset2/caesar.c)|
| |Vigenere|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset2/vigenere.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset2/vigenere.c)|
|2|Music|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset3/helpers.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset3/helpers.c)|
|3|Whodunit|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset4/whodunit.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset4/whodunit.c)|
||Resize|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset4/resize.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset4/resize.c)|
||Recover|yes|[https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset4/recover.c](https://github.com/coolinmc6/CS-concepts/blob/master/CS50-Intro-to-CS/pset4/recover.c)|
|4||||
|5||||
|6||||
|7||||
|8||||
|9||||
|10|*none*|*n/a*||
|11|Final Project|||

# Week 0

**Lecture:** [https://www.youtube.com/watch?v=y62zj9ozPOM&list=PLhQjrBD2T3828ZVcVzEIhsHVgjANGZveu](https://www.youtube.com/watch?v=y62zj9ozPOM&list=PLhQjrBD2T3828ZVcVzEIhsHVgjANGZveu)

- phone book problem => keep splitting in half until you find Mike Smith

# Week 1

source code needs to be converted to machine code for the computer to read it
source code => compiler => machine code
IDE = Integrated Development Environment

`clang hello.c` => compile the code

`./a.out` => execute the code

```c
#include <stdio.h>

int main(void) 
{
	printf("hello, world\n");
}
```

- `clang -o hello hello.c` => compile the file and output a file called "hello"
- with C, you need to specify the kind of data you are creating (i.e. string, int, float, etc.)
- library => collection of functions
- if checking one character in C, you use single quotes; strings use double quotes

```c
#include <stdio.h>

// C is now made aware of the square function
int square(int n);

int main(void)
{
	// get_int is not from the C library
	int x = get_int("x: ");
	// printf("%i\n", x * x)
	printf("%i\n", square(x))
}

int square(int n)
{
	return n * n;
}
```

```c
int main(void)

int main(int argc, string argv[])
// argc => integer
// argv => array of strings

```

# Week 2

## Music Homework Notes
- white keys are the non-sharp keys
- accidentals
	+ sharp = #
	+ flat = b
- C# = Db
- the piano is divided into octaves. The middle octave is Octave 4
- D4 = the D key in the 4th Octave
- C starts the Octaves so it would go from C4-D4-E4-F4-G4-A4-B4-C5
- **bday**
	+ using the sheet music
	+ figure out which notes are being played
	+ write down the ASCII representation in the bday.txt
	+ C4@1/8 => C, fourth octave, eighth note
	+ C#4@1/8 => C#, fourth octave, eighth note
	+ blank line means a resst for 1/8th note
- **helpers.c**
	+ Write three functions:
		* is_reset
		* duration
		* frequency
	+ is_rest
	+ duration
		* `int duration(string fraction)`
		* takes in a fraction as a string and output a whole number representing how many eight notes
		* 1/8 => 1
		* 1/4 => 2
		* 3/8 => 3
		* 1/2 => 4
	+ frequency
		* * `int frequency(string note)`
		* parse the string into a note and its octave => A#4 -> separate into A# and Octave 4
		* calculate the frequency of the note in the given octave
		* return the frequency
		* Frequencies 
			* A4 = 440 Hz
			* Every semitone up => frequency * 2 ^ 1/12
			* Every semitone down => frequency / 2 ^ 1/12
			* if moving two up => f * 2 ^ **2**/12
			* sounds like I will essentially just need to figure out out how many semitones away from A4 I am
			+ A5 = 880 Hz = 440 * 2 ^ 12/12 = 440 * 2 ^ 1 = 440 * 2

## Computational Complexity
- when we talk about about the complexity of an algorithm, we generally reger to the worst-case scenario
	+ this is **Big O**
- best case scenario is **Big Omega**
- We can measure how much it takes up (in resources) in terms of time or memory. This measure is *f(n)*
- Computation Complexity

|Big O|Time|Description
|O(1)|constant time|Always takes a single operation in the worst case|
|O(log n)|logarithmic time|Always takes *n* operations in the worst case|
|O(n)|linear time||
|O(n log n|linearithmic time||
|O(n^2|quadratic time||
|O(n ^C|polynomial time||
|O(c^n|exponential time||
|O(n!)|factorial time||
|O(infinity)|infinite time||

## Selection Sort
- Find the smallest unsorted element and add it to the end of a sorted list
- In pseudocode (repeat this until sorted):
	+ Search the unsorted part of the data to find the smallest value
	+ swap the smallest found value with the first element of the unsorted part
- Worst-case scenario: iterate over each of the n elements (to find the smallest unsorted element) and we must repeat this process *n* times, since only one element gets sorted on each pass
- Best-case scenario: exactly the same! There's no way to guarantee the array is sorted until we go through
the process for all of the elements
- Worst Case: O(n^2)
- Best Case: Omega (n^2)

## Bubble Sort
- In pseudocode:
	+ set swap counter to a non-zero value (i.e. -1; otherwise it won't run once)
	+ repeat until the swap counter is 0:
		* reset swap counter to 0;
		* look at each adjacent pair; if not in order, swap them and add one to the swap counter
- Worst-case scenario: array is in reverse order
- Best-case: array is already perfectly sorted and make no swaps on the first pass
- Worst Case: O(n^2)
- Best Case: Omega (n)

## Insertion Sort
- build your sorted array in place, shifting elements out of the way if necesary to make room as you go
- In pseudocode:
	+ call the first element of the array "sorted"
	+ Repeat until all elements are sorted:
		* Look at the next unsorted element. Insert into the sorted portion by shifting the requisite number
		of elements
- we didn't have to go back and forth across the array
- Worst case scenario: array is in reverse order; we have to shift *n*elements *n* positions each time we make an insertion
- Best case scenario: the array is already perfectly sorted and we simply keep moving the line between "unsorted" and "sorted" as we examine each element
- Worst Case: O(n^2)
- Best Case: Omega (n)

## Merge Sort
- Merge sort leverages recursion
- Break arrays into arrays of one element that are "sorted"
- Essentially: sort the left half, sort the right half, merge the two halves
- Worst-case scenario: split n elements up and then recombine them, effectively doubling the sorted
subarrays as we build them up
- Best case scenario: The array is already perfectly sorted but we will still have to split and recombine it back together
- Worst Case: O(n log n)
- Best Case: Omega (n log n)

## Linear Search
- itrate across the array from left to right, searching for a specified element
- In pseudocode:
	+ repeat, starting at first element:
		* is the first element is what you're looking for? Yes, stop;
		* If No, move to the next element
- Worst-case scenario: we look through entire array of n elements (it's the last item or it's not in the array)
- Best-case scenario: it's the first item
- Worst Case: O(n)
- Best Case: Omega (1)

## Binary Search
- This is divide and conquer => we can only do this if the array is **sorted**
- In pseudocode:
	+ Repeat until the (sub)array is of size 0:
		* calculate midpoint
		* if target, then stop
		* if target < midpoint, move start point to left of that and then divide in half again
- if element does not exist, end point will be lower than start point creating a subarray of 0
- Worst case scenario: we have to divide a list of n elements repeatedly in half either because that's where
the element is or it's not in the array
- Best case scenario: target element is at midpoint of full array
- Worst Case: O(log n)
- Best Case: Omega (1)

## Recursion
- A recursive funciton is one that, as part of its execution, calls itself
- `fact(n) = n * fact(n-1)`
- Every recursive function has two cases that could apply, given any input:
	+ the **base case**, which when triggered will terminate the recursive function
	+ the **recursive case**, which is where the function calls itself

```c
int fact(int n)
{
	if (n == 1) 
	{
		return 1;
	}
	else
	{
		return n * fact(n-1);
	}

}

```

- that can be slimmed down in C if a conditional only has a return line then:

```c
int fact(int n)
{
	if (n == 1) 
		return 1;
	else
		return n * fact(n-1);
}

```

- In general, but not always, recursive functions replace loops in non-recursive functions
- It's possible to have more than one base case
- The Collatz Conjecture applies to positive integers and speculates that it is always possible to get back to 1:
	+ if n is 1, stop
	+ Otherwise, if n is even, repeat this process on n/2
	+ Otherwise, if n is odd, repeat this process on 3n + 1

## Algorithms Summary

|Algorithm Name|Basic Concept|Big O|Omega|
|:---:|:---|:---:|:---:|
|Selection Sort|Find the smallest unsorted element in an array and swap it with first unsorted element in that array|n^2|n^2|
|Bubble Sort|Swap adjacent pairs of elements if they are out of order, effecting "bubbling" larger elements to the right and smaller ones to the left|n^2|n|
|Insertion Sort|Go through the array one time from left to right, shifting elements as necessary to insert each element into its correct place|n^2|n|
|Merge Sort Sort|Split the full array into subarrays, then merge those subarrays back together in the correct order|n log n|n log n|
|Linear Search|Iterate across the array from left-to-right, trying to find the target element|n|1|
|Binary Search|Given a sorted array, divide and conquer by systematically elminating half of the remaining elements in the search for the target|log n|1|

# Week 3

## Whodunit
- take BMP clue
- Items To Do:
	+ open file
	+ update header's info for outfile
	+ read clue's scanline, pixel by pixel
	+ change pixel's color as necessary
	+ write verdict's scanline, pixel by pixel
- `copy.c`
	+ already does a lot of things: opens a file, updates header, reads each scanline, writes each pixel in the output file
- Items to do:
	+ `cp copy.c whodunit.c`
- BITMAPINFOHEADER
	+ biWidth (bitmap info Width)
	+ biHeight
	+ biSizeImage
- BITMAPFILEHEADER
	+ bfSize
		* total size of file (in bytes)
	+ bf.bfSize = bi.biSizeImage + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)
- fread(data, size, number, inptr)
	+ data - pointer to a struct that will contain the bytes you're reading
	+ size - size of each element to read
	+ number - number of elements to read
	+ inptr - FILE * (pointer) to read from
- pixel color - represented by 3 bytes
- RGBTRIPLE scruct
	+ a struct to represent pixels
	+ here is a green pixel:

```c
RGBTRIPLE triple;
triple.rgbtBlue = 0x00;
triple.rgbtGreen = 0xff;
triple.rgbtRed = 0x00;
```

- One way to decode it would be to turn all pure red into white
- writing files
	+ `fwrite(data, size, number, outptr)`
- padding
	+ each pixel is 3 bytes
	+ length of each scanline must be 4 bytes
	+ if the number of pixels isn't 4, we must add some padding (0x00)
	+ each scanline must be a multiple of 4:
		* Ex #1: scanline has 4 RGBtriple's => no padding needed (4 * 3 = 12; 12 is a multiple of 4)
		* Ex #2: scanline has 5 RGBtriple's => 1 byte of padding required (5 * 3 = 15; plus 1 is 16)
			- one byte of padding is 0x00
		* Ex #3: scanline has 6 RGBtriple's => 2 bytes of padding required (6 * 3 = 18; plus 2 is 20)
	+ We don't have to come up with the formula, the padding formula is given
- write padding
	+ `fputc(chr, outptr)`
		* chr => char to write
		* outptr => FILE * to write to
- file position indicator
	+ `fseek(inptr, offset, from);`

## Resize

- bitmaps are just an arrangement of bytes, it's all about how we read them
- Because we are changing the size of the file we have to change the header file
- BITMAPINFOHEADER
	+ biWidth (width of image in pixels)
	+ biHeight (height of image in pixels)
	+ biSizeImage (total size of image in bytes) => includes pixels and padding
- What's changing when scaling by n?
	+ bi.biWidth => bi.biWidth * n
	+ bi.biHeight => bi.biHeight * n
	+ bi.biSizeImage => ((biWidth * n) * sizeof(RGBTRIPLE) + padding) * abs(biHeight * n)
	+ bf.bfSize => sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + biSizeImage
- Resize horizontally
	+ write each pixel twice!
- padding
	+ to write padding, we need `fputc()`
- fseek() needed
- pseudocode:
	+ for each row:
		* for each pixel
			- write to array n times
		* for n times
			- write array to outfile
			- write outfile padding
		* skip over infile padding

## Recover

- TODO
	+ open memory card file
		* fopen
		* check if its null
		* we start at the beginning and check the first few bytes to see if it is a JPEG. If not, we can then
		skip to the next block of 512 bytes
		* CM => right away, I am unsure about how to read the bytes or the proper struct I should be using. The
		looping through the bytes seems easy; it's the comparison of those bytes is what seems hard
	+ find beginning of JPEG
		* once we find a JPEG, we just write 512 bytes at a time until we reach the end of the JPEG
	+ open a new JPEG write 512 bytes until new JPEG is found
	+ 
	+ detect end of file

- JPEGs
	+ each JPEG starts with a distinct header
		* first three bytes: 0xff 0xd8 0xff
		* last byte: 0xe0 0xe1 0xe2 ... 0xef
	+ stored side-by-side on the memory card
	+ each block is 512 bytes
	+ One recommendation is the bitwise and operator:
		* `if (buffer[0] == 0xff && buffer[1] == 0xd8 && buffer[2] == 0xff && (buffer[3] & 0xf0) == 0xe0)`
		* filenames need to be formated as follows: ###.jpg
		* named in the order in which they are found, starting at 000
	+ making a new JPEG
		* `sprintf(filename, "%03i.jpg", 2);`
			- filename: char array to store the resultant string
			- looks like this returns something with 3 places whatever the ith int is where 2 is the
			number we want in there ====> 002.jpg
		- FILE *img = fopen(filename, "w");
- Reading files
	+ fread(data, size, number, inptr)
	+ data: pointer to a **struct** that will contain the bytes you're reading
	+ size: size of each element to read
		* sizeof
	+ number: number of elements to read
	+ inptr: FILE * to read from
	+ fread returns the number of elements successfully read
		* `fread(buffer, 1, 512, raw_file)` OR
		* `fread(buffer, 512, 1, raw_file)`
- Writing files
	+ `fwrite(data, size, number, outptr);`
	+ data - pointer to the struct that contains the bytes you're reading from
	+ size
	+ number
	+ outptr: FILE * to write to
- End of file?
	+ fread returns the number of elements successfully read
		* `fread(buffer, 1, 512, raw_file)` OR
		* `fread(buffer, 512, 1, raw_file)`
	+ `fread(data, size, number, inptr);`
		* return how many items of size `size` were read (and ideally, it returns a number)
		* use directly in a condition!
- pseudocode
	+ open card file
	+ repeat until end of card
		* read 512 bytes into a buffer
		* start of a new JPEG?
			- yes ->
			- no ->
		* already found a JPEG?
			- no ->
			- yes ->
	+ close any remaining files

[back to top](#top)

# Week 4


[back to top](#top)

# Week 5

[back to top](#top)

# Week 6

[back to top](#top)

# Week 7

[back to top](#top)

# Week 8

[back to top](#top)

# Week 9

[back to top](#top)

# Week 10

[back to top](#top)

# Week 11

[back to top](#top)